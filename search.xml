<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字图像处理基础</title>
      <link href="/2019/05/14/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/05/14/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-图像处理"><a href="#1-图像处理" class="headerlink" title="1 图像处理"></a>1 图像处理</h2><h3 id="1-1-点算子"><a href="#1-1-点算子" class="headerlink" title="1.1 点算子"></a>1.1 点算子</h3><p>操作特征：每个像素的输出值只取决于相应的输入像素值。 </p><h4 id="1-1-1-像素变换"><a href="#1-1-1-像素变换" class="headerlink" title="1.1.1 像素变换"></a>1.1.1 像素变换</h4><p>一般的图像处理算子是指一个或多个输入图像到一个输出图像的函数，在连续域中可表示为</p><script type="math/tex; mode=display">g(\boldsymbol{x})=h(f(\boldsymbol{x})) \text { or } g(\boldsymbol{x})=h\left(f_{0}(\boldsymbol{x}), \ldots, f_{n}(\boldsymbol{x})\right)</script><p>$x$属于函数的$D$维定义域，函数$f$和$g$在某个值域上操作。对于离散图像，定义域由有限个像素位置组成，$x=(i,j)$，此时$g(i, j)=h(f(i, j))$</p><p>常用的两个点算子是乘以和加上一个常数，$g(x)=af(x)+b$，$a$称为增益参数，$b$称为偏差参数。$a,b$也可以随着空间位置的不同而变化。</p><script type="math/tex; mode=display">g(\boldsymbol{x})=a(\boldsymbol{x}) f(\boldsymbol{x})+b(\boldsymbol{x})</script><p>二元算子是线性混合算子：</p><script type="math/tex; mode=display">g(\boldsymbol{x})=(1-\alpha) f_{0}(\boldsymbol{x})+\alpha f_{1}(\boldsymbol{x})</script><p>$\alpha \in[0,1]$，此算子可以实现两幅图像或视频间的时间上的淡入淡出。</p><p>伽马矫正是图像预处理阶段经常使用的非线性算子，它可以去除输入辐射量和量化的像素值之间的非线性映射</p><script type="math/tex; mode=display">g(\boldsymbol{x})=[f(\boldsymbol{x})]^{1 / \gamma}</script><p>$\gamma$经常取2.2</p><h4 id="1-1-2-彩色变换"><a href="#1-1-2-彩色变换" class="headerlink" title="1.1.2 彩色变换"></a>1.1.2 彩色变换</h4><p>彩色变换是对彩色图像的三个通道分别操作，比如色彩平衡（白炽光光照的补偿）可以通过对每个通道乘以不同的尺度因子来实现，也可以采用更复杂的处理过程，将RGB映射到XYZ彩色空间。</p><h4 id="1-1-3-合成与抠图"><a href="#1-1-3-合成与抠图" class="headerlink" title="1.1.3 合成与抠图"></a>1.1.3 合成与抠图</h4><p>覆盖算子：$C=(1-\alpha)B+\alpha F$，这个算子通过$(1-\alpha)$因子减弱了背景图像$B$的影响，加入了对应于前景层图像$F$的彩色值（和不透明度，一共4维）</p><h4 id="1-1-4-直方图均衡化"><a href="#1-1-4-直方图均衡化" class="headerlink" title="1.1.4 直方图均衡化"></a>1.1.4 直方图均衡化</h4><p>见其他笔记</p><h2 id="1-2-线性滤波"><a href="#1-2-线性滤波" class="headerlink" title="1.2 线性滤波"></a>1.2 线性滤波</h2><p><strong>何谓图像滤波？</strong></p><p>图像滤波即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。</p><p>信号或图像的能量大部分集中在幅度谱的低频和中频段是很常见的，而在较高频段，感兴趣的信息经常被噪声淹没。因此一个能降低高频成分幅度的滤波器就能够减弱噪声的影响。</p><p> 低通滤波能保留图像的大致轮廓信息是因为，一张图像所记录到的主要信息（由于受到关照等必然因素的影响）在图像上灰度值的变化是缓慢的，因此主要信息集中在低频区域。而噪音等偶然因素是突然附加到图像上使得灰度值快速变化，而且密密麻麻，这导致N个像元内，灰度值的变化不仅频繁，而且变化的范围还很大。因此，噪音就位于图像频谱的高频区域，表现为高灰度值。</p><p><strong>图像滤波的目的</strong></p><p>一是抽出对象的特征作为图像识别的特征模式;<br>二是为适应图像处理的要求，消除图像数字化时所混入的噪声。</p><p><strong>图像滤波的要求</strong></p><p>一是不能损坏图像的轮廓及边缘等重要信息;<br>二是使图像清晰视觉效果好。</p><p>邻域算子（局部算子）是利用给定像素周围的像素的值决定次像素的最终输出值。可用于局部色调调整，还可用于图像滤波，实现图像的平滑和锐化，图像边缘的增强或者图像噪声的去除。</p><p>关于滤波器，一种形象的比喻法是:我们可以把滤波器想象成一个包含加权系数的窗口，当使用这个滤波器平滑处理图像时，就把这个窗口放到图像之上，透过这个窗口来看我们得到的图像。如下邻域算子的介绍。</p><p><img src="juanji.png" alt></p><p>线性滤波算子是一种常用的邻域算子，指用不同的权重结合一个小的邻域内的像素。</p><script type="math/tex; mode=display">g(i, j)=\sum_{k . l} f(i+k \cdot j+l) h(k . l)</script><p>其中权重核或掩膜$h(k,l)$常称为”滤波系数”，上面公式可简写为：$g=f \otimes h$<br>上述公式也常变形为：</p><script type="math/tex; mode=display">g(i, j)=\sum_{k . l} f(i-k, j-l) h(k, l)=\sum_{k, l} f(k, l) h(i-k, j-l)</script><p>此公式称为”卷积公式”，记做$g=f * h$</p><p>相关和卷积运算都可以用矩阵和向量的乘法来表示，如：<br><img src="juzhenjuanji.png" alt></p><p><strong>填塞（边界效应）</strong></p><p>如上图所示的卷积矩阵运算会产生边界效应，即采用这种形式的图像滤波会使角点处的像素变黑（乘积为0）。主要是因为当卷积核超出原始图像边界时，原始图像边界外的部分被认为是有效的，并用0填充（0为黑）</p><p>为了抵消这种效应，可以采用一些对图像填塞或扩展的模式</p><ul><li>0填塞：将原图像之外的像素的值设置为0</li><li>常数填塞（边框彩色）：在原图像外的像素的值设置为确定的边界值</li><li>夹取填塞（复制或夹取边缘）：不限定地复制边缘像素的值</li><li>重复填塞：以环状形态环绕图像进行循环</li><li>镜像填塞：像素围绕图像边界进行镜像反射</li><li>延长：通过在边缘像素值中减去镜像信号的方式延长信号</li></ul><h3 id="1-2-1-可分离的滤波"><a href="#1-2-1-可分离的滤波" class="headerlink" title="1.2.1 可分离的滤波"></a>1.2.1 可分离的滤波</h3><p>对于卷积运算的实现，每个像素需要$K^2$次操作（乘-加），$K$是卷积核的大小。在许多情况下，这种运算可以采用如下计算方式来大幅度提高运算速度：先用一维行向量进行卷积，接着用一维列向量进行卷积。这样每个像素总共需要$2K$次操作。如果一个卷积核可以采用上述方式进行计算，则称其为可分离的。</p><p><img src="fenlijuanji.png" alt></p><p>如果给定一个核函数$K$，如何判断它是不是可分离的呢？更直接的方法是将$2D$核函数看成一个$2D$矩阵$K$并且对其进行奇异值分解（SVD）</p><script type="math/tex; mode=display">\boldsymbol{K}=\sum_{i} \sigma_{i} \boldsymbol{u}_{i} \boldsymbol{v}_{i}^{T}</script><p>当仅有第一个奇异值$\sigma_0$是非$0$值时，核函数是可分离的，$\sqrt{\sigma_{0}} u_{0}$和$\sqrt{\sigma_{0}} v_{0}^{T}$分别提供了垂直核函数和水平核函数。</p><h3 id="1-2-2-带通和导向滤波器"><a href="#1-2-2-带通和导向滤波器" class="headerlink" title="1.2.2 带通和导向滤波器"></a>1.2.2 带通和导向滤波器</h3><p><strong>高斯滤波器</strong>平滑图像：</p><script type="math/tex; mode=display">G(x, y ; \sigma)=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{x^{2}+y^{2}}{2 \sigma^{2}}}</script><p><strong>Laplacian算子</strong>（带通滤波器）对二维图像求二阶导数（无方向）:</p><script type="math/tex; mode=display">\nabla^{2} f=\frac{\partial^{2} f}{\partial x^{2}}+\frac{\partial^{2} f}{\partial y^{2}}</script><p><strong>LoG</strong>（Laplacian of Gaussian）算子：首先用高斯核平滑图像，再用Laplacian算子作用于图像。</p><script type="math/tex; mode=display">\nabla^{2} G(x, y ; \sigma)=\left(\frac{x^{2}+y^{2}}{\sigma^{4}}-\frac{2}{\sigma^{2}}\right) G(x, y ; \sigma)</script><p><strong>Sobel 算子</strong>是一个主要用作<strong>边缘检测</strong>的离散微分算子 (discrete differentiation operator)。 Sobel算子结合了高斯平滑和微分求导，用来计算图像灰度函数的近似梯度。在图像的任何一点使用此算子，将会产生对应的梯度矢量或是其法矢量（带方向）。</p><p><img src="sobel.png" alt></p><p><img src="sobel2.png" alt></p><p>Sobel算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息，边缘定位精度不够高。当对精度要求不是很高时，是一种较为常用的边缘检测方法。<a href="https://my.oschina.net/freeblues/blog/727561" target="_blank" rel="noopener">https://my.oschina.net/freeblues/blog/727561</a></p><p><strong>区域求和表</strong></p><p>区域求和表是指一定区域内所有像素的值的和：</p><script type="math/tex; mode=display">s(i, j)=\sum_{k=0}^{i} \sum_{l=0}^{j} f(k, l)</script><p>从图像的左上角元素开始递归计算，则区域求和的增量公式，即区域求和表的每个元素值为：</p><script type="math/tex; mode=display">s(i, j)=s(i-1, j)+s(i, j-1)-s(i-1, j-1)+f(i, j)</script><p>图像$s(i,j)$也被称为积分图像。在计算机视觉中，人脸检测可利用区域求和表来计算简单的多尺度上的底层特征。<br><img src="qiuhe.png" alt></p><p>（a）为原始图像；（b）为区域求和表</p><p><strong>递归滤波器</strong></p><p>区域求和的增量公式是递归滤波器的一个典型例子。递归滤波器是指输出值取决于前一个滤波器的输出值。这种滤波器又称为”无限脉冲响应（IIR）”，因为对于脉冲信号（只有一个非零值），IIR的输出是无限的。本章前面所研究的用一个有限区域核卷积图像的滤波器称作”有限脉冲响应（FIR）”。<br>IIR滤波器常用于可分离的一维滤波阶段，计算大范围的平滑核。</p><h2 id="1-3-更多的邻域算子"><a href="#1-3-更多的邻域算子" class="headerlink" title="1.3 更多的邻域算子"></a>1.3 更多的邻域算子</h2><h3 id="1-3-1-非线性滤波"><a href="#1-3-1-非线性滤波" class="headerlink" title="1.3.1 非线性滤波"></a>1.3.1 非线性滤波</h3><p>前面考虑的是线性滤波，然而在很多情况下，使用邻域像素的非线性组合可能会得到更好的效果。例如当噪声是散粒噪声，而不是高斯噪声，即图像偶尔会出现很大的值。这种情况下，用高斯滤波器对图像进行模糊，噪声像素是不会被去除的，只会转换为更加柔和但仍然可见的散粒。</p><p><strong>中值滤波</strong></p><p>对于散粒噪声这种情况，使用中值滤波是一个较好的选择。中值滤波器选择每个像素的邻域像素的中值作为输出。这个邻域称之为窗，窗开的越大，输出的结果越平滑，但过大的窗也可能把我们有用的信号特征给抹除。由于散粒噪声通常位于邻域内正常值的两端，故中值滤波可以对这类异常像素进行过滤。</p><p>中值滤波有个不足，即由于中值滤波只选择一个像素作为输出像素，所以一般很难有效去除规则的高斯噪声。</p><p>$\alpha$<strong>截尾均值滤波</strong>会对散粒噪声和高斯噪声做一个折衷，具体做法是指去除百分率为$\alpha$的最小值和最大值后剩下的像素的均值。</p><p>另一种方法是<strong>加权中值滤波</strong>：加权中值滤波是将窗口内的每一个像素都乘上一个相应的权值，然后利用乘上权值后的值进行排序，取中值替换中心元素的灰度值即可。中值滤波可以看做是每个像素的权值都是1的加权中值滤波。权重目标函数最小化如下：</p><script type="math/tex; mode=display">\sum_{k, l} w(k, l)|f(i+k, j+l)-g(i, j)|^{p}</script><p><strong>双边滤波器</strong></p><p>双边滤波器与高斯滤波器相比，对于图像的边缘信息能够更好的保存，其原理为一个与空间距离相关的高斯函数与一个灰度距离相关的高斯函数相乘。等于是双边滤波器既结合了空间距离信息，又结合了灰度距离（值域）信息。</p><p>在双边滤波器中，输出像素的值依赖于邻域像素的值的加权组合：</p><script type="math/tex; mode=display">g(i, j)=\frac{\sum_{k, l} f(k, l) w(i, j, k, l)}{\sum_{k, l} w(i, j, k, l)}</script><p>权重系数$w(i,j,k,l)$取决于定义域核</p><script type="math/tex; mode=display">d(i, j, k, l)=\exp \left(-\frac{(i-k)^{2}+(j-l)^{2}}{2 \sigma_{d}^{2}}\right)</script><p>和依赖于数据的值域核</p><script type="math/tex; mode=display">r(i, j, k, l)=\exp \left(-\frac{\|f(i, j)-f(k, l)\|^{2}}{2 \sigma_{r}^{2}}\right)</script><p>的乘积。它们相乘后，就会产生依赖于数据的双边权重函数</p><script type="math/tex; mode=display">w(i, j, k, l)=\exp \left(-\frac{(i-k)^{2}+(j-l)^{2}}{2 \sigma_{d}^{2}}-\frac{\|f(i, j)-f(k, l)\|^{2}}{2 \sigma_{r}^{2}}\right)</script><h3 id="1-3-2-形态学"><a href="#1-3-2-形态学" class="headerlink" title="1.3.2 形态学"></a>1.3.2 形态学</h3><p>形态学，即数学形态学(mathematical Morphology)，是图像处理中应用最为广泛的技术之一，主要用于从图像中提取对表达和描绘区域形状有意义的图像分量，使后续的识别工作能够抓住目标对象最为本质（最具区分能力一most discriminative)的形状特征，如边界和连通区域等。同时像细化、像素化和修剪毛刺等技术也常应用于图像的预处理和后处理中，成为图像增强技术的有力补充。在数字图像处理中，形态学是借助集合论的语言来描述的。</p><p>设有两幅图像A, S。若A是被处理的对象， 而S是用来处理A的， 则称S为结构元素。结构元素通常都是一些比较小的图像， A与S的关系类似于滤波中图像和模板的关系。</p><p>以下介绍的是二值图像的基本形态学操作，包括腐蚀、膨胀、以及开、闭运算。所有形态学运算都是针对图像的前景物体进行的，在二值图像中，默认白色（接近255）为前景物体，黑色（接近0）为背景。</p><p><strong><em>腐蚀</em></strong></p><p>腐蚀和膨胀是两种最基本的形态学操作，其他的形态学算法都是由这两种基本运算复合而成的。<br><img src="fushi.png" alt></p><p>腐蚀的作用“ 顾名思义，腐蚀能够消融物体的边界，而具体的腐蚀结果与图像本身和结构元素的形状有关。如果物体整体上大于结构元素，腐蚀的结构是使物体变“ 瘦”一圈，而 这一圈到底有多大是由结构元素决定的：如果物体本身小于结构元素， 则在腐蚀后的图像中物体将完全消失：如物体仅有部分区域小于结构元素〈如细小的连通3，则腐蚀后物体会在细连通处断裂，分离为两部分。</p><p>随着腐蚀结构元素的逐步增大，小于结构元素的物体相继消失。由于腐蚀运算具有上述的特点，可以用于滤波。选择适当大小和形状的结构元素，可以滤除掉所有不能 完全包含结构元素的噪声点。然而，利用腐蚀滤除噪声有一个缺点，即在去除噪声点的同时，对图像中前景物体的形状也会有影响，但当我们只关心物体的位置或者个数时，则影响不大。</p><p><strong><em>膨胀</em></strong></p><p><img src="pengzhang.png" alt></p><p>膨胀的作用和腐蚀相反， 膨胀能使物体边界扩大， 具体的膨胀结果与图像本身和结构元素的形状有关。膨胀常用于将图像中原本断裂开来的同一物体桥接起来， 对图像进行二值化之后， 很容易使一个连通的物体断裂为两个部分， 而这会给后续的图像分析（如要基于连通区域的分析统计物体的个数〉造成困扰，此时就可借助膨胀桥接断裂的缝隙。</p><p><strong><em>开运算</em></strong></p><p>开运算和闭运算都由腐蚀和膨胀复合而成， 开运算是先腐蚀后膨胀， 而闭运算是先膨胀后腐蚀。</p><p>一般来说， 开运算可以使图像的轮廓变得光滑， 还能使狭窄的连接断开和消除细毛刺。 如图8.11所示， 开运算断开了团中两个小区域间两个像素宽的连接〈断开了狭窄连接〉，并且去除了右侧物体上部突出的一个小于结构元素的2×2的区域〈去除细小毛刺〉： 但与腐蚀不同的是， 图像大的轮廓并没有发生整体的收缩， 物体位置也没有发生任何变化。 </p><p>根据图8.12 的开运算示意图， 可以帮助大家更好地理解开运算的特点。为了比较， 图中也标示出了相应的腐蚀运算的结果： </p><p><img src="kai.png" alt></p><p><img src="kai2.png" alt></p><p><strong><em>闭运算</em></strong></p><p>闭运算同样可以使轮廓变得光滑， 但与开运算相反， 它通常能够弥合狭窄的间断， 填充小的孔洞。 </p><p><img src="bi.png" alt></p><h3 id="1-3-3-距离变换"><a href="#1-3-3-距离变换" class="headerlink" title="1.3.3 距离变换"></a>1.3.3 距离变换</h3><p>图像的距离变换实现了像素与图像区域的距离变换，对于变换后的距离图像来说，图像中的每个像素的灰度值为该像素与距离其最近的背景像素间的距离，也就是说，给每个像素赋值为离它最近的背景像素点与其距离。这样可以实现二值图像转化为灰度图像。</p><p>根据度量距离的方法不同，距离变换有几种不同的方法，假设像素点$P_1(x_1,y_1),P_2(x_2,y_2)$计算距离的方法常见的有：<br>1、欧式距离，$Distance=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$<br>2、曼哈顿距离，$Distance=|x_2-x_1|+|y_2-y_1|$</p><p>距离变换的一般步骤如下：<br>1、将输入图片转换为二值图像，前景设置为1，背景设置为0；<br>2、自左上起依次进行距离变换：</p><script type="math/tex; mode=display">D(i, j)=\min _{k, l : b(k . l)=0} d(i-k, j-l)</script><p><img src="juli.png" alt></p><p>(a)为原始的二值图像，(b)自顶向下扫描，距离变换，(c)递归计算，(d)距离变换的结果</p><h3 id="1-3-4-连通量"><a href="#1-3-4-连通量" class="headerlink" title="1.3.4 连通量"></a>1.3.4 连通量</h3><p><img src="linyu.jpg" alt></p><h2 id="1-4-傅里叶变换"><a href="#1-4-傅里叶变换" class="headerlink" title="1.4 傅里叶变换"></a>1.4 傅里叶变换</h2><p>傅立叶变换公式，在连续域中</p><script type="math/tex; mode=display">H(\omega)=\int_{-\infty}^{\infty} h(x) e^{-j \omega x} d x</script><p>在离散域中</p><script type="math/tex; mode=display">H(k)=\frac{1}{N} \sum_{x=0}^{N-1} h(x) e^{-j \frac{2 \pi k x}{N}}</script><p>傅立叶变换的性质：<br><img src="xingzhi.png" alt></p><p>傅立叶变换对：<br><img src="dui.png" alt></p><p>图像处理领域用到的傅里叶变换是二维的（长宽方向进行离散傅立叶变换），其目的是得到空间图像的频率分布情况，之后在频率域对图像进行各种处理可以有目的地实现很多功能。如降噪是弱化频率过高的像素点，图像压缩是对图像高频部分的信息进行简化处理，其余的应用还有图像边缘增强、纹理分析等。DC在二维图像信号中表示整幅图像的平均亮度。二维傅里叶图谱中越亮的点对应图像中对比度越大的点，原图频率越集中，对应的频谱图中亮点就越集中。 </p><h3 id="1-4-1-维纳滤波"><a href="#1-4-1-维纳滤波" class="headerlink" title="1.4.1 维纳滤波"></a>1.4.1 维纳滤波</h3><p>在数学应用上，对于运动引起的图像模糊，最简单的方法是直接做逆滤波，但是逆滤波对加性噪声特别敏感，使得恢复的图像几乎不可用。<strong>最小均方差</strong>（维纳）滤波用来去除含有噪声的模糊图像，其目标是找到未污染图像的一个估计，使它们之间的均方差最小，可以去除噪声，同时清晰化模糊图像。</p><p><strong>定义</strong></p><p>给定一个系统</p><script type="math/tex; mode=display">y(t)=h(t) * x(t)+n(t)</script><p>这里，$*$是卷积符号。<br>$x(t)$是在时间tt刻输入的信号（未知）<br>$h(t)$是一个线性时间不变系统的脉冲响应（已知）<br>$n(t)$是加性噪声，与x(t)x(t)不相关（未知）<br>$y(t)$是我们观察到的信号 </p><p>我们的目标是找出这样的卷积函数$g(t)$，这样我们可以如下得到估计的$x(t)$： </p><script type="math/tex; mode=display">\hat{x}(t)=g(t) * y(t)</script><p>这里$\hat x(t)$是$x(t)$的最小均方差估计。<br>基于这种误差度量，滤波器可以在频率域如下描述：</p><script type="math/tex; mode=display">\begin{aligned} G(f) &=\frac{H^{*}(f) S(f)}{|H(f)|^{2} S(f)+N(f)} \\ &=\frac{H^{*}(f)}{|H(f)|^{2}+N(f) / S(f)} \end{aligned}</script><p>这里：<br>$G(f)$ 和$H(f)$是$g$和$h$在频率域ff的傅里叶变换。<br>$S(f)$是输入信号$x(t)$的功率谱。<br>$N(f)$是噪声的$n(t)$的功率谱。<br>上标$*$代表复数共轭。 </p><p>滤波过程可以在频率域完成： </p><script type="math/tex; mode=display">\hat{X}(f)=G(f) * Y(f)</script><p>这里 $\hat X (f)$是 $\hat x (t)$的傅里叶变换，通过逆傅里叶变化可以得到去卷积后的结果$\hat x (t)$。</p><p><strong>解释</strong></p><p>上面的式子可以改写成更为清晰的形式 </p><script type="math/tex; mode=display">\begin{aligned} G(f) &=\frac{1}{H(f)}\left[\frac{|H(f)|^{2}}{|H(f)|^{2}+\frac{N(f)}{S( )}}\right] \\ &=\frac{1}{H(f)}\left[\frac{|H(f)|^{2}}{|H(f)|^{2}+\frac{1}{S N R(f)}}\right] \end{aligned}</script><p>这里$H(f)$是$h$在频率域ff的傅里叶变换。$SNR(f)=S(f)/N(f)$是信号噪声比。当噪声为零时（即信噪比趋近于无穷），方括号内各项也就等于1，意味着此时刻维纳滤波也就简化成逆滤波过程。但是当噪声增加时，信噪比降低，方括号里面值也跟着降低。这说明，维纳滤波的带通频率依赖于信噪比。</p><p><strong>推导</strong></p><p>上面直接给出了维纳滤波的表达式，接下来介绍推导过程。<br>上面提到，维纳滤波是建立在最小均方差，可以如下表示： </p><script type="math/tex; mode=display">e(f)=E|X(f)-\hat{X}(f)|^{2}</script><p>这里$E$是期望。<br>如果我们替换表达式中的$\hat X(f)$，上面可以重新组合成 </p><script type="math/tex; mode=display">\begin{aligned} e(f) &=E|X(f)-G(f) Y(f)|^{2} \\ &=E|X(f)-G(f)[H(f) X(f)+V(f)]|^{2} \\ &=E|[1-G(f) H(f)] X(f)-G(f) V(f)|^{2} \end{aligned}</script><p>展开二次方，得到下式</p><script type="math/tex; mode=display">\begin{aligned} e(f) &=[1-G(f) H(f)][1-G(f) H(f)]^{*} E|\mathrm{X}(\mathrm{f})|^{2} \\ &-[1-G(f) H(f)] G^{*}(f) E\left\{X(f) V^{*}(f)\right\} \\ &-G(f)[1-G(f) H(f)]^{*} E\left\{V(f) X^{*}(f)\right\} \\ &+G(f) G^{*}(f) E|V(f)|^{2} \end{aligned}</script><p>然而，我们假设噪声与信号独立无关，这样有 </p><script type="math/tex; mode=display">E\left\{X(f) V^{*}(f)\right\}=E\left\{V(f) X^{*}(f)\right\}=0</script><p>并且我们如下定义功率谱 </p><script type="math/tex; mode=display">\begin{aligned} S(f) &=E|X(f)|^{2} \\ N(f) &=E|V(f)|^{2} \end{aligned}</script><p>这样有</p><script type="math/tex; mode=display">e(f)=[1-G(f) H(f)][1-G(f) H(f)]^{*} S(f)+G(f) G^{*}(f) N(f)</script><p>为了得到最小值，我们对$G(f)$求导，令方程等于零。</p><script type="math/tex; mode=display">\frac{\mathrm{d}(f)}{\mathrm{d} G(f)}=G^{*}(f) N(f)-H(f)[1-G(f) H(f)]^{*} S(f)=0</script><p>由此最终推出维纳滤波器。</p><h2 id="1-5-金字塔与小波"><a href="#1-5-金字塔与小波" class="headerlink" title="1.5 金字塔与小波"></a>1.5 金字塔与小波</h2><p>前面所研究的是所有图像变换所产生的图像都与输入图像大小相同。但是在一些情况下需要得到不同大小的图像，比如在人脸识别中，由于我们不知道人脸可能出现的尺寸，所以需要生成一个不同大小的图像组成的金字塔，扫描其中每幅图像来寻找可能的人脸。生物视觉系统也会处理分层次的尺寸。通过这样的金字塔，可以先粗粒度的寻找，再细粒度的寻找。<br>改变图像分辨率的操作叫做上采样（插值）和下采样（降采样）。</p><h3 id="1-5-1-上采样（插值）"><a href="#1-5-1-上采样（插值）" class="headerlink" title="1.5.1 上采样（插值）"></a>1.5.1 上采样（插值）</h3><p>要将一幅图像插值到较高分辨率，我们需要选择一些插值核来卷积图像。</p><script type="math/tex; mode=display">g(i, j)=\sum_{k, l} f(k, l) h(i-r k, j-r l)</script><p>这个公式与离散卷积公式有关，我们只是将$h()$中的$k$和$l$替换为$rk$和$rl$，其中，$r$为上采样率。<br>目前比较常用的插值算法有：最近邻插值、双线性内插法、三次内插法</p><p><strong>最近邻插值</strong></p><p>这是最简单的插值方法，不需计算，在待求象素的四邻象素中，将距离待求象素最近的邻象素灰度赋给待求象素。<br><img src="zuijinlin.png" alt><br>最近邻法计算量小，但可能会造成插值生成的图像灰度上的不连续，在灰度变化的地方可能出现明显的锯齿状。</p><p><strong>双线性内插法</strong></p><p>双线性内插法是利用待求象素四个邻象素的灰度在两个方向上作线性内插，如下图所示：<br><img src="shuangxianxing.png" alt></p><p>$f(i+u,j+v)=(1-u)<em>(1-v)</em>f(i,j)+(1-u)<em>v</em>f(i,j+1)+u<em>(1-v)</em>f(i+1,j)+u<em>v</em>f(i+1,j+1)$</p><p>双线性内插法的计算比最邻近点法复杂，计算量较大，但没有灰度不连续的缺点，结果基本令人满意。它具有低通滤波性质，使高频分量受损，图像轮廓可能会有一点模糊。</p><p><strong>三次内插法</strong></p><p>该方法利用三次多项式$S(x)$求逼近理论上最佳插值函数$sin(x)/x$, 其数学表达式为：</p><script type="math/tex; mode=display">S(x)=\left\{\begin{array}{ll}{1-2|x|^{2}+|x|^{3}} & {0 \leq|x|<1} \\ {4-8|x|+5|x|^{2}-|x|^{3}} & {1 \leq|x|<2} \\ {0} & {|x| \geq 2}\end{array}\right.</script><p>待求像素(x, y)的灰度值由其周围16个灰度值加权内插得到，如下图：<br><img src="sanci.png" alt><br>待求像素的灰度计算式如下：</p><script type="math/tex; mode=display">f(x, y)=f(i+u, j+v)=A B C</script><p>其中：<br>$A=\left( \begin{array}{c}{S(1+v)} \\ {S(v)} \\ {S(1-v)} \\ {S(2-v)}\end{array}\right)^{\top}$ $C=\left( \begin{array}{c}{\mathrm{S}(1+\mathrm{u})} \\ {\mathrm{S}(\mathrm{u})} \\ {\mathrm{S}(1-\mathrm{u})} \\ {\mathrm{S}(2-\mathrm{u})}\end{array}\right)$</p><script type="math/tex; mode=display">B=\left( \begin{array}{cccc}{f(i-1, j-1)} & {f(i-1, j)} & {f(i-1, j+1)} & {f(i-1, j+2)} \\ {f(i, j-1)} & {f(i, j)} & {f(i, j+1)} & {f(i, j+2)} \\ {f(i+1, j-1)} & {f(i+1, j)} & {f(i+1, j+1)} & {f(i+1, j+2)} \\ {f(i+2, j-1)} & {f(i+2, j)} & {f(i+2, j+1)} & {f(i+2, j+2)}\end{array}\right)</script><p>三次曲线插值方法计算量较大，但插值后的图像效果最好。</p><h3 id="1-5-2-降采样"><a href="#1-5-2-降采样" class="headerlink" title="1.5.2 降采样"></a>1.5.2 降采样</h3><p>降采样则要求降低分辨率，与插值一样，我们用一个低通滤波器来卷积图像，平滑核$h(k,l)$常常是一个插值核的拉伸和重缩放版本。</p><script type="math/tex; mode=display">g(i, j)=\frac{1}{r} \sum_{k, l} f(k, l) h(i-k / r, j-l / r)</script><p>插值核降采样中使用的核函数$h(k,l)$是相同的。</p><h3 id="1-5-3-多分辨率表达"><a href="#1-5-3-多分辨率表达" class="headerlink" title="1.5.3 多分辨率表达"></a>1.5.3 多分辨率表达</h3><p>图像金字塔是一种以多分辨率来解释图像的结构，通过对原始图像进行多尺度像素采样的方式，生成N个不同分辨率的图像。把具有最高级别分辨率的图像放在底部，以金字塔形状排列，往上是一系列像素（尺寸）逐渐降低的图像，一直到金字塔的顶部只包含一个像素点的图像，这就构成了传统意义上的图像金字塔。<br><img src="jinzita.jpg" alt></p><p>获得图像金字塔一般包括二个步骤：<br>1、利用低通滤波器平滑图像<br>2、对平滑图像进行抽样（采样）<br>有两种采样方式——上采样（分辨率逐级升高）和下采样（分辨率逐级降低）</p><p><strong>高斯金字塔</strong></p><p>高斯金字塔式在Sift算子中提出来的概念，首先高斯金字塔并不是一个金字塔，而是有很多组（Octave）金字塔构成，并且每组金字塔都包含若干层（Interval）。</p><p>高斯金字塔构建过程：</p><ol><li>先将原图像扩大一倍之后作为高斯金字塔的第1组第1层，将第1组第1层图像经高斯卷积（其实就是高斯平滑或称高斯滤波）之后作为第1组金字塔的第2层，高斯卷积函数为：<script type="math/tex; mode=display">G(x, y)=\frac{1}{2 \pi \sigma^{2}} e^{-\frac{\left(x-x_{0}\right)^{2}+\left(y-y_{0}\right)^{2}}{2 \sigma^{2}}}</script></li></ol><p>​       对于参数σ，在Sift算子中取的是固定值1.6。</p><ol><li>将σ乘以一个比例系数k,等到一个新的平滑因子σ=k*σ，用它来平滑第1组第2层图像，结果图像作为第3层。</li><li>如此这般重复，最后得到L层图像，在同一组中，每一层图像的尺寸都是一样的，只是平滑系数不一样。它们对应的平滑系数分别为：0，σ，kσ，k^2σ,k^3σ……k^(L-2)σ。</li><li>将第1组倒数第三层图像作比例因子为2的降采样，得到的图像作为第2组的第1层，然后对第2组的第1层图像做平滑因子为σ的高斯平滑，得到第2组的第2层，就像步骤2中一样，如此得到第2组的L层图像，同组内它们的尺寸是一样的，对应的平滑系数分别为：0，σ，kσ，k^2σ,k^3σ……k^(L-2)σ。但是在尺寸方面第2组是第1组图像的一半。</li></ol><p>这样反复执行，就可以得到一共O组，每组L层，共计O*L个图像，这些图像一起就构成了高斯金字塔，结构如下：<br><img src="gaosijinzita.png" alt></p><p>在同一组内，不同层图像的尺寸是一样的，后一层图像的高斯平滑因子σ是前一层图像平滑因子的k倍；<br>在不同组内，后一组第一个图像是前一组倒数第三个图像的二分之一采样，图像大小是前一组的一半。</p><p><strong>尺度空间</strong></p><p>图像的尺度空间解决的问题是如何对图像在所有尺度下描述的问题。<br>在高斯金字塔中一共生成O组L层不同尺度的图像，这两个量合起来（O，L）就构成了高斯金字塔的尺度空间，也就是说以高斯金字塔的组O作为二维坐标系的一个坐标，不同层L作为另一个坐标，则给定的一组坐标（O,L）就可以唯一确定高斯金字塔中的一幅图像。<br>尺度空间的形象表述：<br><img src="chidukongjian.png" alt></p><p>上图中尺度空间中k前的系数n表示的是第一组图像尺寸是当前组图像尺寸的n倍。</p><p><strong>DOG金字塔</strong></p><p>差分金字塔，DOG（Difference of Gaussian）金字塔是在高斯金字塔的基础上构建起来的，其实生成高斯金字塔的目的就是为了构建DOG金字塔。<br>DOG金字塔的第1组第1层是由高斯金字塔的第1组第2层减第1组第1层得到的。以此类推，逐组逐层生成每一个差分图像，所有差分图像构成差分金字塔。概括为DOG金字塔的第o组第l层图像是有高斯金字塔的第o组第l+1层减第o组第l层得到的。<br>DOG金字塔的构建可以用下图描述：</p><p><img src="DOG.png" alt></p><p>每一组在层数上，DOG金字塔比高斯金字塔少一层。后续Sift特征点的提取都是在DOG金字塔上进行的。<br>DOG金字塔的显示效果如下：<br><img src="DOG1.png" alt></p><p>这些长得黑乎乎的图像就是差分金字塔的实际显示效果，只在第1组第1层差分图像上模糊可以看到一个轮廓。但其实这里边包含了大量<strong>特征点信息</strong>，只是我们人眼已经分辨不出来了。<br>下边对这些DOG图像进行归一化，可有很明显的看到差分图像所蕴含的特征，并且有一些特征是在不同模糊程度、不同尺度下都存在的，这些特征正是Sift所要提取的“稳定”特征：<br><img src="DOG2.png" alt></p><p><strong>拉普拉斯金字塔</strong></p><p>在高斯金字塔的运算过程中，图像经过卷积和下采样操作会丢失部分高频细节信息。为描述这些高频信息，人们定义了拉普拉斯金字塔(Laplacian Pyramid， LP)。用高斯金字塔的每一层图像减去其上一层图像上采样并高斯卷积之后的预测图像，得到一系列的差值图像即为 LP 分解图像。</p><h3 id="1-5-4-小波"><a href="#1-5-4-小波" class="headerlink" title="1.5.4 小波"></a>1.5.4 小波</h3><p>傅里叶变换可以将信号表示为无限三角函数的累加形式，从而实现将信号从空间域到频率域的转换。然而这种转换丢失了信号时空域的信息（只知道频率及其幅值，但不知道该频率发生的空间位置，可以类比直方图），因此无法做局部分析。<br>短时傅里叶变换通过引入一个时间窗函数试图改进傅里叶的局部缺陷，但由于窗函数的尺寸是固定的，不能同时对信号高频和低频做精确分析。<br>小波变换基于可自动调节尺寸的窗函数（图像金字塔），在时域和频域均具有良好的局部化性能，被誉为“数学显微镜”。<br>小波变换在图像处理上可用于去噪、边缘提取（实质就是突出低频或高频），但最主要的应用在于图像压缩。</p><p>既然图像金字塔和小波都将一幅图像分解为空间和频率内的多分辨率描述，它们有什么不同呢?通常的答案是，传统金字塔过于完备，即它们比原图使用更多像素来描述图像分解，而小波提供了一个紧致框架，即它们保持分解图像与原图像大小相等。但是实际上，有一些小波族也是过完备的，以提供更好的移位能力或者方向导向。因此，更好的区别可能是，与常规的带通金字塔相比，小波的方向选择性更佳。</p><p>傅里叶变换将信号分解为不同频率的三角函数之和的形式，小波变换则以尺度函数和小波函数为基，将信号分解。<br>在这里，尺度是通过不断对图像做下采样以建立图像金字塔得到的。<br>尺度函数由低通滤波器构造，小波函数由高通滤波器实现。一次分解有一组小波函数组成（类似傅里叶变换中不同频率的三角函数），这组小波函数由一个母小波函数通过缩放和平移生成。</p><p><img src="xiaobo1.png" alt></p><p>如图2-1所示，h0为尺度函数，h1为小波函数，相应的操作为卷积。结果的f0为上一级的低频近似，f1为上一级水平方向的高频近似，f2为上一级垂直方向的高频近似，f3为上一级对角线方向的高频近似。</p><p><img src="xiaobo2.png" alt></p><p>这里每次的分解都是从上级的低频近似开始，因为图像的大部分信息在低频区域；而<strong>小波包分解</strong>则对低频和高频都做分解。</p><h3 id="1-5-5-金字塔应用：图像融合"><a href="#1-5-5-金字塔应用：图像融合" class="headerlink" title="1.5.5 金字塔应用：图像融合"></a>1.5.5 金字塔应用：图像融合</h3><p><img src="ronghe.png" alt></p><p>如上图所示，将两幅图像拼接融合到一起可以用金字塔模型实现。</p><p><strong>算法原理</strong></p><ol><li><p>首先建立两幅图像高斯金字塔，然后建立一定层数的拉普拉斯金字塔。拉普拉斯金字塔的层数越高，融合效果越好。层数N作为一个参数。</p></li><li><p>传入一个mask掩膜，代表了融合的位置。比如说想在两图的中间进行融合，那么掩膜图像的左半为255，右半为0，反过来是一样的。根据这个mask建立一个高斯金字塔，用于后续融合，层数为N+1。</p></li><li><p>根据mask将两幅图像的拉普拉斯金字塔的图像进行相加，mask为权值。相加的结果即为一个新的金字塔。同时，两幅图像的高斯金字塔的N+1层也进行这个操作，记这个图像为IMG1。</p></li><li><p>根据这个新的金字塔重建出最终的图像，重建的过程跟一般的拉普拉斯金字塔一样。首先对IMG1上采样，然后跟新金字塔的顶层相加，得到IMG2。IMG2进行上采样后跟下一层相加，得到IMG3。重复这个过程，最终得到的结果就是拉普拉斯金字塔融合算法的结果。</p></li></ol><blockquote><p>因为mask建立金字塔的过程中使用了高斯模糊，所以融合的边缘是比较平滑的。</p></blockquote><h2 id="1-6-几何变换"><a href="#1-6-几何变换" class="headerlink" title="1.6 几何变换"></a>1.6 几何变换</h2><p>包含相同内容的两幅图像可能由于成像角度、透视关系乃至镜头自身原因所造成的几何失真而呈现出截然不同的外观，这就给观测者或是图像识别程序带来了困扰。通过适当的几何变换可以最大程度地消除这些几何失真所产生的负面影响，有利于我们在后续的处理和识别工作中将注意力集中子图像内容本身，更确切地说是图像中的对象，而不是该对象的角度和位置等。 因此，几何变换常常作为其他图像处理应用的预处理步骤。</p><p><strong>解决几何变换的一般思路</strong><br>图像几何变换又称为图像空间变换， 它将一幅图像中的坐标位置映射到另一幅图像中的新坐标位置。我们学习几何变换的关键就是要确定这种空间映射关系， 以及映射过程中的变换参数。<br>几何变换不改变图像的像素值， 只是在图像平面上进行像素的重新安排。一个几何变换需要两部分运算：首先是空问变换所需的运算， 如平移、旋转和镜像等， 需要用它来表示输出图像与输入图像之间的〈像素〉映射关系：此外， 还需要使用灰度插值算法， 因为按照这种变换关系进行计算， 输出图像的像素可能被映射到输入图像的非整数坐标上。<br>图像的位置变换主要是用于目标识别中的目标配准。</p><h3 id="1-6-1-全局变化"><a href="#1-6-1-全局变化" class="headerlink" title="1.6.1 全局变化"></a>1.6.1 全局变化</h3><p><strong>图像集合变换的表达式</strong></p><script type="math/tex; mode=display">(x, y)=T\{(u, v)\}</script><ul><li>$(x,y) $为变换后图像像素的笛卡尔坐标，$(u,v)$为原始图像中像素的笛卡尔坐标。</li><li>变换后，如果$(x,y)=(u,v)$，则变换后的图像仅仅是原图像的简单拷贝。</li><li>注意，几何变换不改变像素值，而是改变像素所在的位置。这说明像素的亮度和色彩并不发生变化，仅仅是像素位置发生改变。</li></ul><p><strong>齐次坐标表示</strong></p><ul><li>所谓齐次坐标就是用$N+1$维向量表示N NN维向量。</li><li>平面上的点P PP的坐标为$(x,y)$，其齐次坐标表示为$(wx,wy,w)$ ,其中$w$为任意常数。</li><li>如果规定齐次坐标的第三个分量$w$为1，则称为规范齐次坐标。</li></ul><p><strong>引入齐次坐标的原因</strong></p><ul><li><p>在对图像进行操作时候，经常要对图像连续做几次变换。例如做了平移后再做旋转与缩放。因为旋转、缩放都是线性变换，因此可将旋转和缩放合并成一个变换矩阵来表示，如：</p><script type="math/tex; mode=display">\left[ \begin{array}{lll}{x} & {y} & {1}\end{array}\right]=\left[ \begin{array}{lll}{x_{0}} & {y_{0}} & {1}\end{array}\right]^{T}</script></li><li><p>在直角坐标系中，平移不是线性变换，因此不能与旋转、缩放等操作合并成一个变换矩阵。</p></li><li><strong>引入齐次坐标后，平移变为线性变换，从而可以采用一个通用的变换模型（仿射变换模型）表示图像的各种几何变换。</strong></li></ul><p><strong>仿射变换</strong></p><script type="math/tex; mode=display">\left[ \begin{array}{lll}{x} & {y} & {1}\end{array}\right]=\left[ \begin{array}{lll}{x_{0}} & {y_{0}} & {1}\end{array}\right]^{T}</script><ul><li><p>T仿射矩阵</p><script type="math/tex; mode=display">T=\left[ \begin{array}{lll}{a} & {b} & {p} \\ {c} & {d} & {q} \\ {m} & {n} & {s}\end{array}\right]</script></li><li><p>$a b c d$：实现比例变换、旋转变换、偏移变换m</p></li><li>$m n$：实现平移变换、$m $和$n$分别为$X$和$Y$方向的平移量。</li><li>$s$：实现等比例变换</li><li>$p q $：实现透视变换</li></ul><p><img src="pingyi.png" alt></p><p><img src="jingxiang.png" alt></p><p><img src="xuanzhuan.png" alt></p><p><img src="xingzhuang.png" alt></p><p><img src="bili.png" alt></p><h3 id="1-6-2-基于网格的卷绕"><a href="#1-6-2-基于网格的卷绕" class="headerlink" title="1.6.2 基于网格的卷绕"></a>1.6.2 基于网格的卷绕</h3><p>在一些情况下需要对局部的图像进行几何变化。例如，人脸从皱眉到微笑的表观变化。 怎样才能在这个情况下将嘴角向上卷翘而保持脸的其他部分不动呢？要进行这样的变换，在图像的不同部分需要不同数量的运动。下图展示了一些常用的方法。<br><img src="juanrao.png" alt><br>(a)稀疏控制点-&gt;变形网格；(b)控制点对应的稠密集；(c)有向直线对应；(d)一致的四边形网格</p><h3 id="1-6-3-应用：基于特征的变形"><a href="#1-6-3-应用：基于特征的变形" class="headerlink" title="1.6.3 应用：基于特征的变形"></a>1.6.3 应用：基于特征的变形</h3><p>尽管卷绕可以用于改变单幅图像的外观或使其成为一个动画，但用一个通常称为“变形”的过程将两幅或更多图像卷绕并混合起来可以获得更强大的效果。<br>下图展示了图像变形的本质。在两幅图像中进行简单地渐隐渐现(cross-dissolving)会导致上面一行所显示的鬼影，取而代之，每幅图像在融合之前经过向另一幅图像卷绕，如下面一行所示。如果建立了好的对应关系(用上图所展示的任何一种方法)，对应的特征便会对齐，因而不会有鬼影结果。<br><img src="bianxing.png" alt></p><p>上行：如果两幅图像直接混合，会导致可见的鬼影。下行：先将两幅图像都卷绕到同样的中间位置（例如向另一幅图像的中间），然后将得到的卷绕图像混合，产生一个无缝的变形。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Image processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Show and Tell-A Neural Image Caption Generator</title>
      <link href="/2019/05/12/%5B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%5DShow-and-Tell-A-Neural-Image-Caption-Generator/"/>
      <url>/2019/05/12/%5B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%5DShow-and-Tell-A-Neural-Image-Caption-Generator/</url>
      
        <content type="html"><![CDATA[<blockquote><p>论文题目：《Show and Tell: A Neural Image Caption Generator》</p><p>论文链接：<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Vinyals_Show_and_Tell_2015_CVPR_paper.pdf" target="_blank" rel="noopener">https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Vinyals_Show_and_Tell_2015_CVPR_paper.pdf</a></p><p>代码链接：<a href="https://github.com/joczu/Show_and_Tell" target="_blank" rel="noopener">https://github.com/joczu/Show_and_Tell</a></p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>图像内容描述是人工智能领域的基础问题，是计算机视觉与自然语言处理的交叉领域。众所周知，CNN在目标检测和识别中的效果非常的出色，而RNN在机器翻译中也得到了充分的发挥。本文就是在两者的基础上对两种模型进行组合形成一个新的生成式模型称为NIC，实现图像内容描述的任务。</p><p><img src="NIC.png" alt></p><p>作者的思想源泉来自于目前比较前沿的机器翻译，给定一个源句子$S$，将其输入到模型中得到目标语言的句子$T$，模型所要做的就是$\max P(T|S)$。<br>目前机器翻译中比较火的模型莫属RNNs，RNNs可作为Encoder，把源句子编码成一个固定长度的词向量表示，又可作为Decoder生成目标句子。<br>在本文中，作者使用CNN来代替RNNs的Encoder功能，将输入图像编码成固定长度的词向量表示，这样做的原因在于CNN在图像特征提取中表现极为出色。CNN+RNNs这种端到端的神经网络使用起来相当方便。</p><p>由于普通的RNN会出现梯度消失和梯度爆炸的现象，所以采用更加优良的LSTM模型。</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p><img src="cnnrnn.png" alt></p><p>如图所示，LSTM+CNN模型就是一个图像内容生成器。CNN将输入图像进行特征表示，生成512维的表示向量输入到第一个LSTM单元中，作为$t=-1$时刻，$S_i$代表某个单词的向量，采用one-hot编码，长度为整个词表的长度，$W_e$是词向量表示，$W_eS_i$为隐含层的词向量表示，长度也为512维。前向传播的过程如下：</p><script type="math/tex; mode=display">\begin{aligned} x_{-1} &=\operatorname{CNN}(I) \\ x_{t} &=W_{e} S_{t}, \quad t \in\{0 \ldots N-1\} \\ p_{t+1} &=\operatorname{LSTM}\left(x_{t}\right), \quad t \in\{0 \ldots N-1\} \end{aligned}</script><p>上面说到，模型训练的目标为：</p><script type="math/tex; mode=display">\theta^{\star}=\arg \max _{\theta} \sum_{(I, S)} \log p(S | I ; \theta) \\ \log p(S | I)=\sum_{t=0}^{N} \log p\left(S_{t} | I, S_{0}, \ldots, S_{t-1}\right)</script><p>其中$I$为输入的图像，$S$为生成的句子，$\theta$是模型的参数，我们要做的就是最大化这个目标函数，获得模型的参数$\theta$。(此处最大似然之后取log形式)</p><p>上述Log似然公式，恰好对应到RNN的网络中，在$t$时刻，需要计算当前词$S_t$的概率，则可以将历史词$S_0$到$S_{t-1}$表示为一个确定长度的隐含层神经元向量$h_t$，同时输入图像$x_t$，在$t+1$时刻，隐含层向量被更新：</p><script type="math/tex; mode=display">h_{t+1}=f\left(h_{t}, x_{t}\right)</script><h2 id="推断策略"><a href="#推断策略" class="headerlink" title="推断策略"></a>推断策略</h2><ul><li>Sampling：直接将前一个词输入下一个时间点</li><li>BeamSearch：第一个时间点，输出top k个候选词，这k个候选词分别输入第二个时间点，得到若干个第一个和第二个词组合，从这选择得分top k的，输入到第三个时间点，依次迭代</li></ul><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><ul><li>每个时刻的LSTM单元共享一套参数</li><li>单词采用one-hot的表示方法</li><li>每个句子前后都有标志词，表示句子的开始和结束</li><li>图像只需要初始时输入一次（每个时刻都输入，会因噪声很容易过拟合，效果不好）</li><li>本文使用VGG16训练好的模型参数初始化CNN网络</li></ul>]]></content>
      
      
      <categories>
          
          <category> Image Caption </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MTCNN</title>
      <link href="/2019/05/06/%E3%80%8AJoint-Face-Detection-and-Alignment-using-Multi-task-Cascaded-Convolutional-Networks%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/06/%E3%80%8AJoint-Face-Detection-and-Alignment-using-Multi-task-Cascaded-Convolutional-Networks%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>论文题目：《Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks》<br>论文链接：<a href="https://arxiv.org/abs/1604.02878" target="_blank" rel="noopener">https://arxiv.org/abs/1604.02878</a><br>官方代码链接：<a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">https://github.com/kpzhang93/MTCNN_face_detection_alignment</a><br>其他代码链接：<a href="https://github.com/YYuanAnyVision/mxnet_mtcnn_face_detection" target="_blank" rel="noopener">https://github.com/YYuanAnyVision/mxnet_mtcnn_face_detection</a><br>其他代码链接：<a href="https://github.com/Seanlinx/mtcnn" target="_blank" rel="noopener">https://github.com/Seanlinx/mtcnn</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>传统的人脸检测和人脸对齐任务忽略了它们之间固有的联系而各自分析，这样在本文作者看来是不可取的。本文提出了采用深度级联多任务网络（MTCNN）<strong>同时</strong>解决检测和对齐任务。MTCNN网络包含三个阶段的卷积网络（Proposal Network、Refine Network、Output Network）用来检测人脸和检测关键点位置。另外，本文提出一种Online hard sample mining strategy极大提高了算法在实践中的速度。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="3.png" alt></p><p>首先把图像resize成不同尺度的图像金字塔作为网络的输入；</p><ul><li>Stage 1:  Proposal Network, P-Net<br>获得人脸的候选窗口和候选框的回归向量，然后候选框依据估计的边框回归向量进行校准，最后利用Non-maximum suppression(NMS)归并重叠范围比较大的候选框。</li><li>Stage 2: Refine Network, R-Net<br>将第一阶段产生的候选框输入到R-Net，筛选掉大量的非人脸候选框，并且使用边框回归向量进行校准，利用NMS进行归并；</li><li>Stage 3: Output Network, O-Net<br>与第二阶段相似，增加了输出5个人脸关键点位置。</li></ul><p><img src="full.png" alt></p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>与网络的三阶段对应，MTCNN训练过程可以考虑三个阶段的损失，分别是人脸/非人脸二分类、边框回归、面部关键点位置。</p><ol><li><p>人脸识别<br>这是个二分类问题，对于每一个样本$x_i$，$p_i$是样本$x_i$为人脸的概率，真实标签$y_i^{det}\in {\lbrace 0,1\rbrace}$则采用交叉熵损失函数：</p><script type="math/tex; mode=display">L_{i}^{d e t}=-\left(y_{i}^{d e t} \log \left(p_{i}\right)+\left(1-y_{i}^{d e t}\right)\left(1-\log \left(p_{i}\right)\right)\right)</script></li><li><p>边框回归<br>采用欧式距离损失（L2 Loss）,最小化生成的边框坐标与真实边框坐标的欧式距离。对于每个样本$x_i$，$\hat y_i^{box}$表示其回归生成的边框坐标，$y_{i}^{b o x}$是真实的边框坐标。</p><script type="math/tex; mode=display">L_{i}^{b o x}=\left\|\hat{y}_{i}^{b o x}-y_{i}^{b o x}\right\|_{2}^{2}</script></li><li><p>人脸关键点位置<br>与边框回归相似，最小化回归生成的关键点坐标$\widehat{y}_{i}^{l a n d m a r k}$与真实的关键点坐标$y_{i}^{l a n d m a r k}$的欧式距离。$\widehat{y}_{i}^{l a n d m a r k}$代表左右眼睛/鼻子/左右嘴巴角的坐标，共10维向量。</p><script type="math/tex; mode=display">L_{i}^{l a n d m a r k}=\left\|\widehat{y}_{i}^{l a n d m a r k}-y_{i}^{l a n d m a r k}\right\|_{2}^{2}</script></li><li><p>Three Tasks’ loss Sum<br>在实践中对于每个阶段的网络都定义总的损失函数<strong>同时</strong>计算三种损失，这样不至于在求一种损失时，另外两种损失为零。作者在文章中提出在P-Net和R-Net中使用（$\alpha _{det}=1,\alpha_{box}=0.5,\alpha _{landmark}=0.5$）而在O-Net中使用（$\alpha _{det}=1,\alpha_{box}=0.5,\alpha _{landmark}=1$）这说明每个阶段的训练目标有所差异，在P-Net和R-Net中主要是检测人脸和产生边框，O-Net主要是产生关键点位置。</p><script type="math/tex; mode=display">\min \sum_{i=1}^{N} \sum_{j \in\{\text {det}, b o x, l a n d m a r k\}} \alpha_{j} \beta_{i}^{j} L_{i}^{j}</script></li><li><p>Online Hard Sample mining<br>传统的人脸二分类最小化误差时，是对每个样本都进行反向误差传播，这样计算量比较大。本文提出一种新的方法来解决人脸识别在线应用问题。<br>对于每一个mini-batch前向传播产生的loss进行降序排序，从全部的sample中挑选出Top 70%作为hard sample，然后在反向传播中仅仅计算这些hard sample产生的梯度。</p></li></ol><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p><a href="https://blog.csdn.net/u014380165/article/details/78906898" target="_blank" rel="noopener">https://blog.csdn.net/u014380165/article/details/78906898</a></p>]]></content>
      
      
      <categories>
          
          <category> Face Detection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MTCNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improving GAN</title>
      <link href="/2019/04/28/Improving-GAN/"/>
      <url>/2019/04/28/Improving-GAN/</url>
      
        <content type="html"><![CDATA[<p>本文对GAN进行更加深入的探讨，主要参考<a href="https://www.bilibili.com/video/av9770302/?p=16" target="_blank" rel="noopener">哔哩哔哩-李宏毅深度学习2017</a>视频的讲解。</p><h2 id="1-统一架构-FGAN"><a href="#1-统一架构-FGAN" class="headerlink" title="1. 统一架构-FGAN"></a>1. 统一架构-FGAN</h2><h3 id="1-1-f-divergence"><a href="#1-1-f-divergence" class="headerlink" title="1.1 f-divergence"></a>1.1 f-divergence</h3><p>这一章节是为了说明GAN中描述$P_G$和$P_{data}$两个分布差异不一定非要用JS divergence，还有其他的divergence可以替代。</p><p><img src="f.png" alt></p><p>其中P和Q表示两个分布，$p(x)$和$q(x)$是采样出来的x的可能性。f是一个凸函数，并且其极值是$f(1)=0$，$D_f(P||Q)$衡量PQ两个分布之间的差异。<br>如果$p(x)=q(x)$，代入等式可得$D_f(P||Q)=0$；<br>当$p(x)!=q(x)$，$D_f(P||Q) \geq f(\int \limits_xq(x) \frac {p(x)}{q(x)})=f(x)=0$<br>当P和Q两个同分布时，$D_f(P||Q)$有最小值0。</p><p>当然f函数可以取很多形式，如下所示<br><img src="fall.png" alt></p><h3 id="1-2-Fenchel-Conjugate"><a href="#1-2-Fenchel-Conjugate" class="headerlink" title="1.2 Fenchel Conjugate"></a>1.2 Fenchel Conjugate</h3><p>细节内容见<a href="/2019/04/27/凸优化-Jensen不等式-共轭函数-Fenchel不等式/" title="凸优化:Jensen不等式-共轭函数-Fenchel不等式">凸优化:Jensen不等式-共轭函数-Fenchel不等式</a></p><p><img src="fc.png" alt></p><p><img src="fc2.png" alt></p><p><img src="fc3.png" alt></p><p><img src="fc4.png" alt></p><h2 id="2-WGAN"><a href="#2-WGAN" class="headerlink" title="2. WGAN"></a>2. WGAN</h2><p>对于传统的GAN来说，选定特定的Divergence度量函数之后，就开始训练使得两个分布的差异尽可能接近。但是使用f-Divergence也会有很多的问题，比如最严重的问题就是当两个分布之间完全没有重叠时，分布间距离的大小并不会直接体现在Divergence 上，这对于基于迭代的优化算法是致命的。<br>WGAN与传统的GAN却别就是度量分布差异的方式不用，WGAN使用Earth mover’s distance（EMD），顾名思义就是把一个分布变成另一个分布需要花费的最小力气。</p><h3 id="2-1-Earth-Mover’s-Distance"><a href="#2-1-Earth-Mover’s-Distance" class="headerlink" title="2.1 Earth Mover’s Distance"></a>2.1 Earth Mover’s Distance</h3><p><img src="emd.png" alt></p><p>如上图图所示，如何把P分布经过’搬运’变成Q分布，并且使得’搬运’的代价最小，显然有很多方法取移动，那么如何评估’搬运’的代价大小呢，方法很多，如果我们假定衡量代价大小的标准是”移动的数量”或者”移动的平均距离”那么这两个移动方案肯定能分出优劣的。</p><p><img src="emd2.png" alt></p><p>当我们用分布$Q$上不同颜色的色块对应$P$的相应位置，就可以将最好的移动方案化成上面的样子。为了便于形式化定义，我们将这个变化画成一个矩阵，如下图：</p><p><img src="plan.png" alt></p><p>矩阵内的红色色块代表从$P$分布到$Q$分布对应位置’搬运’的量。<br>$\gamma$’搬运’方法的平均移动距离表示为：</p><script type="math/tex; mode=display">B(\gamma )=\sum \limits_{x_p,x_q} \gamma (x_p,x_q)||x_p-x_q||</script><p>Earth Mover’s Distance指的是上述所有方案中平均移动距离最小的那个方案：</p><script type="math/tex; mode=display">W(P,Q)=\min \limits_{\gamma}B(\gamma)</script><p>为什么可以说EMD的方法比JSD的方法好呢，我们可以从下面的图可以看出：<br><img src="bijiao.png" alt><br>在前50轮训练中，JSD的值一直是$log2$，不能很好的衡量两个分布的差异；而EMD的值可以一直的变化，这样收敛的速度就相对较快了。</p><h3 id="2-2-Related-to-GAN"><a href="#2-2-Related-to-GAN" class="headerlink" title="2.2 Related to GAN"></a>2.2 Related to GAN</h3><p>由上节内容知 F-Divergence定义为：<br>$D_f(P_{data}||P_G) = \max \limits_{D} \lbrace E_{x\sim P_{data}}[D(x)]-E_{x \sim P_{G}}[f^*(D(x))] \rbrace$<br>EMD也可以类似的表示出来：<br>$W(P_{data},P_G)=\max \limits_{x \sim 1-Lipschitz} \lbrace E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)] \rbrace$<br>公式中$1-Lipschitz$表示一个函数集，当$f$是一个Lipschitz函数时，它应该满足$||f(x_1)-f(x_2)||\leq K||x_1-x_2||$。当$K=1$时，这个函数就是$1-Lipschitz$函数，直观来说，这个限制是为了让函数的变化更加缓慢一些。如下图所示，绿色的线属于$1-Lipschitz$函数，而蓝色的线不是。<br><img src="lip.png" alt></p><p>为什么要限制生成器D是$1-Lipschitz$函数呢，我们来分析一下当D不是$1-Lipschitz$函数时的情况。<br>我们假设有两个一维分布，$x_1$和$x_2$的距离是$d$，显然他们之间的EMD也是$d$<br><img src="d.png" alt><br>此时我们优化$W(P_{data},P_G)=\max \limits_D \lbrace E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)] \rbrace$时，只需要$D(x_1)=+\infty$，$D(x_2)=-\infty$即可，这样判别器的区分能力太强了，训练起来很困难，很难驱使生成器提高生成分布数据质量。</p><p>如果我们加上$||D(x_1)-D(x_2)|| \leq ||x_1-x_2||=d$的限制，如果我们想要满足上面的优化目标，就可以让$D(x_1)=k+d,D(x_2)=k$，其中$k$具体是什么无所谓，关键是我们通过$d$将判别器在不同分布上的结果限制在了一个较小的范围。</p><p>这样做有什么好处呢？因为传统GAN的判别器是一个最终经过sigmoid函数输出的神经网络，它输出的曲线是S型的，在真实分布附近是1，在生成分布附近是0。当我们加上$||D(x_1)-D(x_2)|| \leq ||x_1-x_2||=d$的限制时，判别器最后一层就不再需要sigmoid函数。<br><img src="sig.png" alt><br>传统的判别器有饱和区（靠近真实和生成分布的地方，函数变化平缓，梯度趋于0），经过限制之后，输出成为了一条直线，训练过程得到加快。</p><blockquote><ol><li>判别器输出层不需再用sigmoid函数</li><li>换成受限的$1-Lipschitz$来实现类似sigmoid的范围限制功能</li><li>生成器和判别器的Loss不需再取log（因为换了Divergence方式）</li></ol></blockquote><p>如何对判别器网络添加$1-Lipschitz$的限制呢？文章中采用简单暴力的方法：截取权重，将权重限制到$[-c,c]$之间，这样限制变成了$K-Lipschitz$，如何调整$K$，只能靠多次调试了。<br><img src="clip.png" alt><br>图中斜率比较陡峭的就是没有截断的函数，截断之后函数会逆时针旋转，产生$1-Lipschitz$的效果。</p><p>原始的GAN算法流程如下：<br><img src="gan.png" alt><br>WGAN的算法如下：<br><img src="wgan.png" alt></p><h2 id="3-改进WGAN"><a href="#3-改进WGAN" class="headerlink" title="3. 改进WGAN"></a>3. 改进WGAN</h2><p>在上节原始的WGAN中，我们通过截取权重（Weight Clipping）的方法实现对判别器D的$1-Lipschitz$限制。$1-Lipschitz$函数有一个特性：当一个函数是$1-Lipschitz$函数时，它的梯度的范数将永远小于等于1，即:</p><p><script type="math/tex">D \in 1-Lipschitz \leftrightarrow ||\nabla_xD(x) \leq 1</script>  for all x<br>此时WGA你的优化目标就是在$1-Lipschitz$中挑选一个函数作为判别器D。</p><p>在Improved WGAN中这样定义：（W相当于Origin GAN中的V，越大越好）<br>$W(P_{data},P_G)=\max \limits_D \lbrace E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)] \rbrace -\lambda \int_xmax(0,||\nabla_xD(x)||-1)dx$<br>也就是说判别器的寻找范围不再是$1-Lipschitz$中的函数，而是任意函数。但是后面增加了一项惩罚项。这个惩罚项能够让选中的判别函数倾向于是一个”对输入梯度为1”的函数，这样就近似的实现了Weight Clipping的效果。</p><p>但与之前一样，求积分无法计算，我们还是采用采样的方法去加惩罚项，即：<br>$W(P_{data},P_G)=\max \limits_D \lbrace E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)] \rbrace -\lambda E_{x \sim P_{penalty}}max(0,||\nabla_xD(x)||-1)dx$</p><p>也就是说，在训练过程中，从$P_{penalty}$中采样使得每一个$x$都能满足$||\nabla_xD(x)||\leq 1$</p><p>Improved WGAN设计了一个特别的$P_{penalty}$，产生过程如下：</p><ol><li>从$P_{data}$中采样一个点</li><li>从$P_G$中采样一个点</li><li>将两个点连线</li><li>在连线上采样得到一个点，这就是从$P_{penalty}$中采样的点</li></ol><p>重复以上过程就能不断采样得到$x \sim P_{penalty}$，最终蓝色的区域就可以看作是$P_{penalty}$<br><img src="penalty.png" alt></p><p>也就是说，我们采样的范围不是整个$x$，而是P_G和$P_{data}$之间的部分。<br>进一步整理，Improved GAN真正做的事是这样：<br>$W(P_{data},P_G)=\max \limits_D \lbrace E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)] \rbrace -\lambda E_{x \sim P_{penalty}}(||\nabla_xD(x)||-1)^2 \rbrace dx$<br>这个惩罚项的目的是让梯度尽可能趋向于1。大于1小于1都会受到惩罚。这样的好处就像是SVM中强调最大类间距离一样，找到可以将数据划分开的最好超平面；这里要做的目的是由于可能存在多个判别器，我们想要找到的那个分类器应该有一个”最好的形状”。<br>一个”好”的判别器应该在$P_{data}$附近是尽可能大，在$P_G$附近尽可能的小。也就是说处于$P_{data}$和$P_G$之间的$P_{penalty}$区域应该有一个比较”陡峭的“梯度，但是这个陡峭的梯度是有限制的，最好是1。</p><h2 id="4-参考阅读"><a href="#4-参考阅读" class="headerlink" title="4. 参考阅读"></a>4. 参考阅读</h2><p><a href="https://alberthg.github.io/2018/05/13/wgan/" target="_blank" rel="noopener">生成对抗网络-FGAN和WGAN</a></p>]]></content>
      
      
      <categories>
          
          <category> GAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> Earth Mover&#39;s Distance </tag>
            
            <tag> f-divergence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸优化:Jensen不等式-共轭函数-Fenchel不等式</title>
      <link href="/2019/04/27/%E5%87%B8%E4%BC%98%E5%8C%96-Jensen%E4%B8%8D%E7%AD%89%E5%BC%8F-%E5%85%B1%E8%BD%AD%E5%87%BD%E6%95%B0-Fenchel%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <url>/2019/04/27/%E5%87%B8%E4%BC%98%E5%8C%96-Jensen%E4%B8%8D%E7%AD%89%E5%BC%8F-%E5%85%B1%E8%BD%AD%E5%87%BD%E6%95%B0-Fenchel%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h2><p>凸函数的定义：$f(\theta x+(1-\theta)y) \leq \theta f(x)+(1-\theta)f(y)$<br>其含义就是：函数图像在直线下边。</p><h2 id="Jensen不等式"><a href="#Jensen不等式" class="headerlink" title="Jensen不等式"></a>Jensen不等式</h2><p>凸函数定义推广到一般形式，即可得到Jensen不等式，即<br>$\theta_1,…\theta_k\geq0, \theta_1+…+\theta_k=1$时，<br>$f(\theta_1x_1+…+\theta_kx_k) \leq \theta_1f(x_1)+…+\theta_kf(x_k)$</p><p>扩展理解：对于$\theta_1,…\theta_k\geq0, \theta_1+…+\theta_k=1$，如果把$\theta_k$看出$x_k$的概率的话，那$\theta_1x_1+…+\theta_kx_k$就表示x的期望，右边式子就表示$f(x)$的期望，于是上式就可以写成$f(E(x))\leq E(f(x))$，这就是Jensen不等式，注意函数f要满足凸函数。</p><h2 id="共轭函数"><a href="#共轭函数" class="headerlink" title="共轭函数"></a>共轭函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>原函数$f:R^n\to R$共轭函数定义：<br><img src="gonge.png" alt><br>这个式子的意思是：求$xt-f(x)$关于x和y函数在定义域内的上界，将这个上界形成的函数定义为共轭函数。下图红色部分就是上界<br><img src="sub.png" alt></p><ol><li><p>定义式中$f(x)$不一定是凸函数</p></li><li><p>共轭函数一定是凸函数（由图可知）</p></li><li><p>凸函数的共轭函数的共轭函数是其本身</p></li></ol><h3 id="如何求共轭函数"><a href="#如何求共轭函数" class="headerlink" title="如何求共轭函数"></a>如何求共轭函数</h3><p><img src="fan.png" alt></p><h2 id="Fenchel不等式"><a href="#Fenchel不等式" class="headerlink" title="Fenchel不等式"></a>Fenchel不等式</h2><p>由共轭函数定义可知，$f^<em>(t) \geq xt-f(x)$ 移项可得 $f(x)+f^</em>(t) \geq xt$ 这就是Fenchel不等式。</p>]]></content>
      
      
      <categories>
          
          <category> 凸优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jensen不等式 </tag>
            
            <tag> 共轭函数 </tag>
            
            <tag> Fenchel不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo填坑</title>
      <link href="/2019/04/26/Hexo%E5%A1%AB%E5%9D%91/"/>
      <url>/2019/04/26/Hexo%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul><li>创建Hexo工程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><p>此处blog可以替换成你想要的名字。</p><ul><li>新建博文</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd blog</span><br><span class="line">$ hexo new &apos;blog-name&apos;</span><br></pre></td></tr></table></figure><p>此时会在/blog/sources/_post/目录下生成’blog-name.md’文件和’blog-name’的文件夹。md文件用于编辑博文，文件夹用于存放此博文内容照片。</p><ul><li>运行服务器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>本地访问<a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>，查看Hexo网站。</p><ul><li>生成上传至GitHub</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><ul><li>安装主题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /blog/themes</span><br><span class="line">$ git clone https://github.com/wuchong/jacman.git ./jacman</span><br><span class="line">$ cd ./jacman</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>然后修改站点配置文件/blog/config.yml，将其中的theme改成jacman</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: jacman</span><br></pre></td></tr></table></figure><ul><li>LaTex数学公式渲染</li></ul><p>先把node_modules文件夹下的渲染器删掉，再输入下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ul><li>插入图片</li></ul><p>将照片放在与博文同名的文件夹下面，在博文中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](pic.png)</span><br></pre></td></tr></table></figure><p>即可饮用，但是这种方法不能改变图片大小，可采用下面命令修改图片大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&apos;pic.png&apos; width = &apos;80%&apos; height = &apos;80%&apos; &gt;</span><br></pre></td></tr></table></figure><ul><li>文件下载链接</li></ul><p>在blog/sources/files内放入上传的文件，在博文中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](/files/filename)</span><br></pre></td></tr></table></figure><h2 id="LaTex公式编辑"><a href="#LaTex公式编辑" class="headerlink" title="LaTex公式编辑"></a>LaTex公式编辑</h2><ul><li>插入数学公式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$数学公式$ 或者 $$数学公式$$</span><br></pre></td></tr></table></figure><p>前者是行内公式，后者是行间公式</p><ul><li>区块引用</li></ul><p><code>&gt;</code>后面书写引用</p><ul><li><p>分割线</p><p><code>***</code>或者<code>---</code></p></li><li><p>上下标</p></li></ul><p>使用^表示上标，表示下标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x^2 </span><br><span class="line">x_&#123;1,2...,n&#125;</span><br><span class="line">\sum \limits^n \limits_&#123;i=1&#125;</span><br><span class="line">\hat x              //字母上加^</span><br><span class="line">$\overline x$       //字母上加横线 </span><br><span class="line">$\widetilde x$      //字母上加波浪线</span><br><span class="line">$\dot&#123;x&#125;$           //字母上加一个点 </span><br><span class="line">$\ddot&#123;x&#125;$          //字母上加两个点</span><br></pre></td></tr></table></figure><ul><li>波浪线</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sim</span><br></pre></td></tr></table></figure><ul><li>公式换行对齐</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;split&#125;</span><br><span class="line">y &amp;= a(x + b) \\&amp;= ax+ab  </span><br><span class="line">\end&#123;split&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><ul><li>括号</li></ul><p><code>()</code>和<code>[]</code>都表示它们自己，但是<code>{}</code>因为有特殊作用需要用<code>\lbrace \rbrece</code>表示。</p><ul><li>分数</li></ul><p><code>\frac{分母}{分子}</code>来表示分数</p><ul><li>开方</li></ul><p><code>\sqrt[次数][被开方数]</code>来表示开方</p><ul><li>求期望</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathbb&#123;E&#125;</span><br></pre></td></tr></table></figure><ul><li>正负无穷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+\infty</span><br><span class="line">-\infty</span><br></pre></td></tr></table></figure><ul><li>希腊字母</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">大写</th><th style="text-align:center">代码</th><th style="text-align:left">小写</th></tr></thead><tbody><tr><td style="text-align:center"><code>A</code></td><td style="text-align:center">$A$</td><td style="text-align:center"><code>\alpha</code></td><td style="text-align:left">$\alpha$</td></tr><tr><td style="text-align:center"><code>B</code></td><td style="text-align:center">$B$</td><td style="text-align:center"><code>\beta</code></td><td style="text-align:left">$\beta$</td></tr><tr><td style="text-align:center"><code>\Gamma</code></td><td style="text-align:center">$\Gamma$</td><td style="text-align:center"><code>\gamma</code></td><td style="text-align:left">$\gamma$</td></tr><tr><td style="text-align:center"><code>\Delta</code></td><td style="text-align:center">$\Delta$</td><td style="text-align:center"><code>\delta</code></td><td style="text-align:left">$\delta$</td></tr><tr><td style="text-align:center"><code>E</code></td><td style="text-align:center">$E$</td><td style="text-align:center"><code>\epsilon</code></td><td style="text-align:left">$\epsilon$</td></tr><tr><td style="text-align:center"><code>Z</code></td><td style="text-align:center">$Z$</td><td style="text-align:center"><code>\zeta</code></td><td style="text-align:left">$\zeta$</td></tr><tr><td style="text-align:center"><code>H</code></td><td style="text-align:center">$H$</td><td style="text-align:center"><code>\eta</code></td><td style="text-align:left">$\eta$</td></tr><tr><td style="text-align:center"><code>\Theta</code></td><td style="text-align:center">$\Theta$</td><td style="text-align:center"><code>\theta</code></td><td style="text-align:left">$\theta$</td></tr><tr><td style="text-align:center"><code>I</code></td><td style="text-align:center">$I$</td><td style="text-align:center"><code>\iota</code></td><td style="text-align:left">$\iota$</td></tr><tr><td style="text-align:center"><code>K</code></td><td style="text-align:center">$K$</td><td style="text-align:center"><code>\kappa</code></td><td style="text-align:left">$\kappa$</td></tr><tr><td style="text-align:center"><code>\Lambda</code></td><td style="text-align:center">$\Lambda$</td><td style="text-align:center"><code>\lambda</code></td><td style="text-align:left">$\lambda$</td></tr><tr><td style="text-align:center"><code>M</code></td><td style="text-align:center">$M$</td><td style="text-align:center"><code>\mu</code></td><td style="text-align:left">$\mu$</td></tr><tr><td style="text-align:center"><code>N</code></td><td style="text-align:center">$N$</td><td style="text-align:center"><code>\nu</code></td><td style="text-align:left">$\nu$</td></tr><tr><td style="text-align:center"><code>\Xi</code></td><td style="text-align:center">$\Xi$</td><td style="text-align:center"><code>\xi</code></td><td style="text-align:left">$\xi$</td></tr><tr><td style="text-align:center"><code>O</code></td><td style="text-align:center">$O$</td><td style="text-align:center"><code>\omicron</code></td><td style="text-align:left">$\omicron$</td></tr><tr><td style="text-align:center"><code>\Pi</code></td><td style="text-align:center">$\Pi$</td><td style="text-align:center"><code>\pi</code></td><td style="text-align:left">$\pi$</td></tr><tr><td style="text-align:center"><code>P</code></td><td style="text-align:center">$P$</td><td style="text-align:center"><code>\rho</code></td><td style="text-align:left">$\rho$</td></tr><tr><td style="text-align:center"><code>\Sigma</code></td><td style="text-align:center">$\Sigma$</td><td style="text-align:center"><code>\sigma</code></td><td style="text-align:left">$\sigma$</td></tr><tr><td style="text-align:center"><code>T</code></td><td style="text-align:center">$T$</td><td style="text-align:center"><code>\tau</code></td><td style="text-align:left">$\tau$</td></tr><tr><td style="text-align:center"><code>\Upsilon</code></td><td style="text-align:center">$\Upsilon$</td><td style="text-align:center"><code>\upsilon</code></td><td style="text-align:left">$\upsilon$</td></tr><tr><td style="text-align:center"><code>\Phi</code></td><td style="text-align:center">$\Phi$</td><td style="text-align:center"><code>\phi</code></td><td style="text-align:left">$\phi$</td></tr><tr><td style="text-align:center"><code>X</code></td><td style="text-align:center">$X$</td><td style="text-align:center"><code>\chi</code></td><td style="text-align:left">$\chi$</td></tr><tr><td style="text-align:center"><code>\Psi</code></td><td style="text-align:center">$\Psi$</td><td style="text-align:center"><code>\psi</code></td><td style="text-align:left">$\psi$</td></tr><tr><td style="text-align:center"><code>\Omega</code></td><td style="text-align:center">$\Omega$</td><td style="text-align:center"><code>\omega</code></td><td style="text-align:left">$\omega$</td></tr></tbody></table></div><ul><li><p>其他字符</p><ul><li>关系运算符</li></ul><p>|     符号     | 代码         |<br>| :—————: | :—————- |<br>|    $\pm$     | <code>\pm</code>        |<br>|   $\times$   | <code>\times</code>     |<br>|    $\div$    | <code>\div</code>       |<br>|    $\mid$    | <code>\mid</code>       |<br>|   $\nmid$    | <code>\nmid</code>      |<br>|   $\cdot$    | <code>\cdot</code>      |<br>|   $\circ$    | <code>\circ</code>      |<br>|    $\ast$    | <code>\ast</code>       |<br>|  $\bigodot$  | <code>\bigodot</code>   |<br>| $\bigotimes$ | <code>\bigotimes</code> |<br>| $\bigoplus$  | <code>\bigoplus</code>  |<br>|    $\leq$    | <code>\leq</code>       |<br>|    $\geq$    | <code>\geq</code>       |<br>|    $\neq$    | <code>\neq</code>       |<br>|  $\approx$   | <code>\approx</code>    |<br>|   $\equiv$   | <code>\equiv</code>     |<br>|    $\sum$    | <code>\sum</code>       |<br>|   $\prod$    | <code>\prod</code>      |<br>|  $\coprod$   | <code>\coprod</code>    |</p><ul><li>集合运算符</li></ul><p>|    符号     | 代码        |<br>| :————-: | :————— |<br>| $\emptyset$ | <code>\emptyset</code> |<br>|    $\in$    | <code>\in</code>       |<br>|  $\notin$   | <code>\notin</code>    |<br>|  $\subset$  | <code>\subset</code>   |<br>|  $\supset$  | <code>\supset</code>   |<br>| $\subseteq$ | <code>\subseteq</code> |<br>| $\supseteq$ | <code>\supseteq</code> |<br>|  $\bigcap$  | <code>\bigcap</code>   |<br>|  $\bigcup$  | <code>\bigcup</code>   |<br>|  $\bigvee$  | <code>\bigvee</code>   |<br>| $\bigwedge$ | <code>\bigwedge</code> |<br>| $\biguplus$ | <code>\biguplus</code> |<br>| $\bigsqcup$ | <code>\bigsqcup</code> |</p><ul><li>对数运算符</li></ul><p>|  符号  | 代码   |<br>| :——: | :——- |<br>| $\log$ | <code>\log</code> |<br>| $\lg$  | <code>\lg</code>  |<br>| $\ln$  | <code>\ln</code>  |</p><ul><li>三角运算符</li></ul><p>|   符号   | 代码     |<br>| :———: | :———- |<br>|  $\bot$  | <code>\bot</code>   |<br>| $\angle$ | <code>\angle</code> |<br>|  $\sin$  | <code>\sin</code>   |<br>|  $\cos$  | <code>\cos</code>   |<br>|  $\tan$  | <code>\tan</code>   |<br>|  $\cot$  | <code>\cot</code>   |<br>|  $\sec$  | <code>\sec</code>   |<br>|  $\csc$  | <code>\csc</code>   |</p><ul><li>微积分运算符</li></ul><p>|     符号     | 代码         |<br>| :—————: | :—————- |<br>|   $\prime$   | <code>\prime</code>     |<br>|    $\int$    | <code>\int</code>       |<br>|   $\iint$    | <code>\iint</code>      |<br>|   $\iiint$   | <code>\iiint</code>     |<br>|  $\iiiint$   | <code>\iiiint</code>    |<br>|   $\oint$    | <code>\oint</code>      |<br>|    $\lim$    | <code>\lim</code>       |<br>|   $\infty$   | <code>\infty</code>     |<br>|   $\nabla$   | <code>\nabla</code>     |<br>| $\mathrm{d}$ | <code>\mathrm{d}</code> |</p><ul><li>箭头</li></ul><p><img src="jiantou.png" alt></p><ul><li>不常用符号</li></ul><p><img src="buchangyong.png" alt></p><ul><li>非数学符号</li></ul><p><img src="feishuxue.png" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> LaTex </tag>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAN初识</title>
      <link href="/2019/04/25/GAN%E5%88%9D%E8%AF%86/"/>
      <url>/2019/04/25/GAN%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>GAN的相关知识主要是跟着李宏毅老师入门的，具体内容可以访问<a href="https://www.bilibili.com/video/av9770302/?p=15" target="_blank" rel="noopener">哔哩哔哩-李宏毅深度学习2017</a>进行学习。这篇文章主要对学习内容进行总结。</p><h2 id="1-传统生成模型"><a href="#1-传统生成模型" class="headerlink" title="1.传统生成模型"></a>1.传统生成模型</h2><h3 id="AutoEncoder"><a href="#AutoEncoder" class="headerlink" title="AutoEncoder"></a>AutoEncoder</h3><blockquote><p>AutoEncoder是前馈神经网络的一种，曾经重要用于数据的降维或者特征的抽取，而现在也被广泛用于生成模型。与其他前馈神经网络不同的是，其他前馈神经网络关注的是Output Layer和错误率，而AutoEncoder关注点是Hidden Layer；并且普通前馈神经网络一般比较深，而AutoEncoder通常只有一层Hidden Layer。Hidden Layer中神经元组成的向量（Code）用来表示Input</p></blockquote><img src="/2019/04/25/GAN初识/autoencoder.png"><p>如图该模型的作用是生成与原图像相似的图像。将原始图像输入神经网络，经过Encoder的压缩，表示成Code；再经过Decoder的解压生成图像；最后计算生成图像与输入图像的MSE（Mean Square Error），这样就可以对模型进行训练。</p><p><img src="Decoder.png" alt></p><p>若只取AutoEncoder的Decoder部分，随机生成Code向量输入网络进行解码，这样就可以生成图像。</p><p>但是从上图可以看出AutoEncoder的图像生成效果非常的差，从计算loss方式分析其原因。</p><p><img src="7.png" width="40%" height="40%"></p><p>可以从上图中看出，两幅图像仅仅一个像素点的位置不同，但是用MSE计算loss是一样大的，这就说明MSE不能衡量图像像素点的位置信息。</p><p>GAN就出场了，设计了Generator和Discriminator结构进行前馈运算，采用KL/JSD等方式，很好的解决了衡量两个图像分布之间‘difference’的问题。</p><h2 id="2-GAN前馈流程图"><a href="#2-GAN前馈流程图" class="headerlink" title="2.GAN前馈流程图"></a>2.GAN前馈流程图</h2><p><img src="generator.png" width="70%" height="70%"></p><p><img src="discriminator.png" width="25%" height="25%"></p><p>初始化Generator和Discriminator网络参数，服从特定分布的随机变量输入Generator网络生成图像（标签为0），再和真实图像（标签为1）一块输入到Discriminator进行判断。</p><p>若是Discriminator对生成图像的判分较低，则Generator参数进行梯度下降更新（此时固定Discriminator）；再将第二轮Generator生成的图像输入到Discriminator进行判断，若是Discriminator对其判分较高，则更新Discriminator参数。</p><h2 id="3-GAN原理"><a href="#3-GAN原理" class="headerlink" title="3.GAN原理"></a>3.GAN原理</h2><ul><li><h3 id="Maximum-Likelihood-Estimation"><a href="#Maximum-Likelihood-Estimation" class="headerlink" title="Maximum Likelihood Estimation"></a>Maximum Likelihood Estimation</h3></li></ul><p>给定真实数据分布$ P_{data}(x)$，此处的x代表真实图像构成的向量；设生成模型的分布$P_{G}(x;\theta)$，这个生成分布由$\theta$决定，生成图像模型的目标就是使得生成模型分布$P_{G}(x;\theta)$尽可能的接近真实数据分布$ P_{data}(x)$，也就是要计算$\theta$。</p><p>这样就可以采用最大似然估计的方法来，具体方法如下：</p><ol><li>从真实数据分布$ P_{data}(x)$中采样得到${x^1,x^2,…,x^m}$；</li><li>计算每个数据的概率$P_G(x^i;\theta)$</li><li>计算似然：$L = \prod_{i=1}^mP_G(x^i;\theta)$</li><li>求得$\theta$使得似然最大化</li></ol><p><img src="MLE.png" width="75%" height="75%"></p><p>使用最大似然估计求得$\theta$的过程如上图所示，对似然求log变成log似然；真实分布中的所有x的期望等价于概率积分，所以可以转化成积分运算，因为减号之后的积分与$\theta$无关，所以添加上去之后还是等价的；经过这样拼凑之后最大似然估计可以变成求两个分布之间的KL散度，两个分布越相似，KL散度值越小。</p><p>在求$\theta$之前必须要假定生成分布的类型，比如是高斯混合模型，但是在实践中这种假设的效果不太好，所以如何能设计出更加一般化的生成模型分布呢？</p><p>这里采用神经网络来产生生成分布$P_{G}(x;\theta)$，$\theta$也就是神经网络的权重参数。神经网络只要有非线性激活函数，理论上可以去拟合任意函数，概率分布也可以看作是函数映射，所以可以采用神经网络去学习复杂的概率分布。</p><p><img src="GAN%20Distribution.png" width="70%" height="70%"></p><ul><li><p>Generator G</p><p>生成器G是一个函数，输入向量z，输出向量x</p><p>$P_{prior}(z)$表示输入向量z的先验分布，$P_G(x)$由生成器G决定</p></li><li><p>Discriminator D</p><p>判别器D是一个函数，输入向量x，输出标量值</p><p>D用来衡量$P_G(x)$与$P_{data}(x)$之间的不同</p></li><li><p>GAN公式</p><p>$G^*=arg\min\limits_{G}\max\limits_{D}V(G,D)$    </p><p>$V=E_{x \sim P_{data}}[logD(x)]+E_{x \sim P_{G}}[log(1-D(x))]$ 衡量$P_G$与$P_{data}$的不同</p><p>在G一定的情况，寻找D使得$V(G,D)$最大化，也就是对于真实分布中的x，D(x)要接近1，对于生成分布中的x，D(x)要接近于0，这样使得判别器的能力增强；<br>再固定D，寻找G使得$\max\limits_{D}V(G,D)$最小，也就是让来自于生成分布中的x的D(x)尽可能的接近1，这样使得生成器的能力增强。</p></li></ul><p>接下来对$G^*=arg\min\limits_{G}\max\limits_{D}V(G,D)$进行求解。</p><ul><li><h3 id="求解-min-limits-G-max-limits-D-V-G-D"><a href="#求解-min-limits-G-max-limits-D-V-G-D" class="headerlink" title="求解$\min \limits_{G}\max \limits_{D}V(G,D)$"></a>求解$\min \limits_{G}\max \limits_{D}V(G,D)$</h3></li></ul><p>给定G，求得最优的$D^*$使得V最大。</p><p><img src="maxv.png" width="70%" height="70%"></p><p>接下来给定x，求$D^*$使得被积函数取极大值。$P_{data}(x)$和$P_{G}(x)$是已知值，只   需要对D求导即可得到极大值。</p><p><img src="D*.png" width="70%" height="70%"></p><p>将$D^*$代入V式进行整理。</p><p><img src="maxv%E6%8E%A8%E5%AF%BC.png" width="70%" height="70%"></p><p>$log2P_{data}(x)$对x积分之后得$log2$，概率积分为1。</p><p><img src="maxv%E6%8E%A8%E5%AF%BC2.png" width="70%" height="70%"></p><p>上图的推导主要是凑出JSD分布的形式，JS Divergence是KL散度的对称平滑版本，也是描述了两个分布之间的差异。因为JSD值域[0,log2]所以 $\max \limits_DV(G,D)$的取值范围为[-2log2,0]。</p><p>接下来的问题就是如何优化G，使得$P_G(x)$尽可能接近$P_{data}(x)$</p><p><img src="G.png" width="40%" height="40%"></p><p>如上图，将$\max \limits_DV(G,D)$视为损失函数$L(G)$，采用梯度下降的方法进行优化</p><p><img src="G2.png" width="40%" height="40%"></p><h2 id="4-GAN训练"><a href="#4-GAN训练" class="headerlink" title="4.GAN训练"></a>4.GAN训练</h2><p><img src="%E8%AE%AD%E7%BB%83.png" width="65%" height="65%"></p><p>如图所示，在实践训练中，我们不可能求得$P_G$和$P_{data}$的期望，所以只能从真实数据分布和生成数据分布中分别采样，代入到损失函数求的交叉熵。</p><p>具体的算法流程如下</p><p><img src="%E7%AE%97%E6%B3%95.png" width="65%" height="65%"></p><h2 id="5-问题优化"><a href="#5-问题优化" class="headerlink" title="5.问题优化"></a>5.问题优化</h2><ul><li><h3 id="训练初期缓慢"><a href="#训练初期缓慢" class="headerlink" title="训练初期缓慢"></a>训练初期缓慢</h3></li></ul><p><img src="%E7%94%9F%E6%88%90%E5%99%A8%E4%BC%98%E5%8C%96.png" width="25%" height="25%"></p><p>在生成模型的优化过程中，生成器的loss Function是$V=E_{x\sim P_{G}}[-log(1-D(x))]$。如上图所示，当D(x)接近0的时候，梯度非常的小。这就导致在训练的初期，生成器G如果想要骗过判别器D变化是非常的缓慢的。所以就将生成器的loss修改成$V=E_{x\sim P_{G}}[-log(D(x))]$这样可以提高训练的速度。</p><ul><li><h3 id="Loss不变"><a href="#Loss不变" class="headerlink" title="Loss不变"></a>Loss不变</h3></li></ul><p>在实际训练中发现，loss一直不发生变化，即$\max \limits_DV(G,D)=0$</p><p>因为JSD值域是[0,log2]，这也就是说明$P_G$和$P_{data}$没有相似之处，但是实际上两个分布是有相似之处的，出现问题的原因是我们在积分运算中国使用采样的方法，当训练过拟合的时候，D还是能把两部分的点给分开的，如下图所示。</p><p><img src="%E8%BF%87%E6%8B%9F%E5%90%88.png" width="40%" height="40%"></p><p>我们是不是应该让D变得弱一点，减弱它的分类能力，但是我们的初衷是让D变得更强，这就产生了矛盾。</p><p>还有一种原因可能是，两个分布都是高维的，但是两个分布都十分的窄，交集相当的小，这就导致JSD比较大。</p><p>解决方法：添加噪声，让两个分布变得更宽一些，这样可以增大它们之间的交集，在训练过程中，再使噪声逐渐减小。</p><ul><li><h3 id="Mode-Collapse"><a href="#Mode-Collapse" class="headerlink" title="Mode Collapse"></a>Mode Collapse</h3></li></ul><p><img src="mode.png" width="50%" height="50%"></p><p>如上图所示，实际训练过程种可能出现这样的情况，真实的数据分布是双峰分布的，而生成的数据分布只拟合了其中一个峰的分布，也就是说没有学到整个分布。</p><p>造成这种情况的原因是，KL散度中两个分布写反了。</p><p><img src="mode2.png" width="50%" height="50%"></p><p>如上图所示，若是第一KL散度的写法，为了防止出现无穷大，所有有$P_{data}$出现的地方都必须有$P_G$覆盖，这样就不回出现Mode Collapse。</p><h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6.代码"></a>6.代码</h2><p><a href="/files/originGAN.py">GAN代码实现</a></p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><a href="https://www.cnblogs.com/bonelee/p/9166084.html" target="_blank" rel="noopener">https://www.cnblogs.com/bonelee/p/9166084.html</a></p>]]></content>
      
      
      <categories>
          
          <category> GAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> MLE </tag>
            
            <tag> AutoEncoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/04/14/404/"/>
      <url>/2019/04/14/404/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（4）——串、数组和广义表</title>
      <link href="/2018/09/17/2018-09-17-data-struct-summary-4/"/>
      <url>/2018/09/17/2018-09-17-data-struct-summary-4/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="串的定义、存储结构以及计算"><a href="#串的定义、存储结构以及计算" class="headerlink" title="串的定义、存储结构以及计算"></a>串的定义、存储结构以及计算</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4></li><li>计算机上的非数值处理的对象大部分是字符串数据，字符串一般简称为串。串是一种特殊的线性表，其特殊性体现在数据元素是一个字符；    </li><li>零个字符的串称为空串；只有空格的字符串称为空格串；<h4 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h4>串也有两种基本的存储结构：顺序存储和链式存储，但考虑到存储效率和算法的方便性，串多采用<strong>顺序存储结构</strong>。</li><li>串的顺序存储<blockquote><p>串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。    </p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//---串的定长顺序存储结构---</span><br><span class="line">#define MAXLEN 255    //串的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXLEN+1];</span><br><span class="line">    int length;    //串的当前长度</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//---串的堆式顺序存储结构---</span><br><span class="line">typedef struct&#123;</span><br><span class="line">     char *ch;//若是非空串，则按串长分配存储区，否则为空</span><br><span class="line">     int length;//串的当前长度</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><ul><li>串的链式存储<br>链表的结点可以存放一个字符，也可以存放多个字符，称为结点的大小。链表的最后一个结点不一定全被串值占满，此时通常补上“#”或其他的非串值字符。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//---串的链式存储结构---</span><br><span class="line">#define CHUNKSIZE 80</span><br><span class="line">typedef struct Chunk&#123;    //定义每个结点的存储结构</span><br><span class="line">     char ch[CHUNKSIZE];</span><br><span class="line">     struct Chunk *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">     Chunk *head,*tail;   //串的头和尾指针</span><br><span class="line">     int length;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure></li></ul><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p>确定主串中所含子串第一次出现的位置（定位）</p><h4 id="BF（Brute-Force）算法"><a href="#BF（Brute-Force）算法" class="headerlink" title="BF（Brute Force）算法"></a>BF（Brute Force）算法</h4><ul><li>算法思想<br>（1）将主串的第pos个字符和模式的第一个字符比较，若相等，继续逐个比较后续字符；若不等，从主串的下一字符起，重新与模式的第一个字符比较；<br>（2）直到主串的一个连续子串字符序列与模式相等 。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功；<br>（3）否则，匹配失败，返回值 0；<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/BF%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B.PNG" alt="BF算法"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int  Index(Sstring S,Sstring T,int pos)&#123;</span><br><span class="line">    i=pos;j=1;</span><br><span class="line">   while (i&lt;=S[0] &amp;&amp; j&lt;=T[0])&#123;</span><br><span class="line">       if (S[i]=T[j]) &#123;++i;++j;&#125;</span><br><span class="line">       else&#123;i=i-j+2;j=1;&#125;</span><br><span class="line">   if (j&gt;T[0])   return i－T[0];</span><br><span class="line">   else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>利用已经<strong>部分匹配</strong>的结果而加快模式串的滑动速度，且主串S的指针i不必回溯！可提速到O(n+m)！<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95%E6%B1%82next%E5%80%BC.PNG" alt="KMP算法求next值"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int Index_KMP(SString S,SString T,int pos,int next[])</span><br><span class="line">&#123; // 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">//其中，T非空，1≤pos≤StrLength(S)</span><br><span class="line">int i=pos, j=1;</span><br><span class="line">while (i&lt;=S[0] &amp;&amp; j&lt;=T[0])</span><br><span class="line">if (j==0||S[i]==T[j]) // 继续比较后继字</span><br><span class="line">&#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    j=next[j]; // 模式串向右移动</span><br><span class="line">if (j&gt;T[0]) // 匹配成功</span><br><span class="line">    return i-T[0];</span><br><span class="line">else</span><br><span class="line">    return 0;</span><br><span class="line">&#125;//Index_KMP</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95%E5%8C%B9%E9%85%8D%E6%AD%A5%E9%AA%A4.PNG" alt="KMP算法匹配步骤"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//---计算next函数值---</span><br><span class="line">void get_next(SString T, int next[])</span><br><span class="line">&#123; //求模式串T的next函数值并存入数组next</span><br><span class="line">int i=1, j=0;</span><br><span class="line">next[1]=0;</span><br><span class="line">while(i&lt;T[0])</span><br><span class="line">if (j==0||T[i]==T[j])</span><br><span class="line">&#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++j;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">  j=next[j];</span><br><span class="line">&#125;//get_next</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//计算next函数的修正值</span><br><span class="line">void get_nextval(SString T,int nextval[])</span><br><span class="line">&#123;</span><br><span class="line">     i=1;nextval[1]=0;j=0;</span><br><span class="line">     while(i&lt;T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        if(j==0||T.ch[i]==T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">            if(T.ch[i]!=T.ch[j]) nextval[i]=j;</span><br><span class="line">            else nextval[i]=nextval[j];</span><br><span class="line">         &#125;</span><br><span class="line">         else j=nextval[j];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95%E6%B1%82nextval%E5%80%BC.PNG" alt="KMP求nextval值"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（3）——栈与队列</title>
      <link href="/2018/09/13/2018-09-13-data-struct-summary-3/"/>
      <url>/2018/09/13/2018-09-13-data-struct-summary-3/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="栈的表示和操作的实现"><a href="#栈的表示和操作的实现" class="headerlink" title="栈的表示和操作的实现"></a>栈的表示和操作的实现</h3><h4 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h4></li><li><strong>顺序栈的存储结构</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct     //栈的存储结构</span><br><span class="line">&#123;</span><br><span class="line">    ElemType *base;</span><br><span class="line">    ElemType *top;</span><br><span class="line">    int stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>（1） base为栈底指针，初始化完成后，栈底指针base始终指向栈底的位置，若base为NULL，则表明栈结构不存在；<br>（2） top为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1；<br>（3） 栈空时，top和base的值相等，都指向栈底；栈非空时，top始终指向栈顶元素的上一个位置；<br>（4） stacksize为栈可使用的最大容量；    </p></blockquote><ul><li><p><strong>顺序栈的初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status InitStack(SqStack &amp;S)    //栈的初始化</span><br><span class="line">&#123;</span><br><span class="line">     S.base=new ElemType[MAXSIZE];    //为顺序栈分配一个MAXSIZE的数组空间</span><br><span class="line">     if(!S.base) return ERROR;</span><br><span class="line">     S.top=S.base;</span><br><span class="line">     S.stacksize=MAXSIZE;</span><br><span class="line">     return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>压栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status Push(SqStack &amp;S,ElemType e)    //压栈</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top-S.base==S.stacksize) return ERROR;    //判断是否到达最大容量</span><br><span class="line">    *S.top=e;</span><br><span class="line">    ++S.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>出栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status Pop(SqStack &amp;S,ElemType &amp;e)    //出栈</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top==S.base) return ERROR;     //判断栈是否为空</span><br><span class="line">    e=*--S.top;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取栈顶元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status GetTop(SqStack S)    //获取栈顶元素</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top!=S.base)    //判断栈是否为空</span><br><span class="line">       return *(S.top-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h4><ul><li><strong>链栈的存储结构</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct StackNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct StackNode *next;</span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>链栈的存储结构与点链表的存储结构相同，由于栈的主要操作是在栈顶插入和删除，显然以链表的头部作为栈顶是最方便的，因此链栈不需设置头结点。    </p><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status InitStack(LinkStack &amp;S)</span><br><span class="line">&#123;</span><br><span class="line">    S=NULL;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p><strong>压栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status Push(LinkStack &amp;S,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode *p;</span><br><span class="line">    InitStack(p);    //为结点开辟内存空间</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S;</span><br><span class="line">    S=p;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>出栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status Pop(LinkStack &amp;S,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode *p;</span><br><span class="line">    e=S-&gt;data;</span><br><span class="line">    p=S;</span><br><span class="line">    S=S-&gt;next;</span><br><span class="line">    delete p;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取栈顶元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElemType GetTop(LinkStack S)</span><br><span class="line">&#123;</span><br><span class="line">    if(S!=NULL)return S-&gt;data;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h3><h4 id="循环队列—队列的顺序表示和实现"><a href="#循环队列—队列的顺序表示和实现" class="headerlink" title="循环队列—队列的顺序表示和实现"></a>循环队列—队列的顺序表示和实现</h4><ul><li><strong>队列的存储结构</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct     </span><br><span class="line">&#123;</span><br><span class="line">    ElemType *base;</span><br><span class="line">    int front; //整型变量，在此叫做头指针</span><br><span class="line">    int rear;  //整型变量，在此叫做尾指针</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>（1） 初始化创建空队列时，令<code>front=rear=0</code>；<br>（2） 每当插入新的队列尾元素时，尾指针rear增1；每当删除队列头元素时，头指针front增1；<br>（3） 在非空队列中，头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一位置；<br>（4） 队空的条件：<code>Q.front=Q.rear</code><br>（5） 队满的条件：<code>(Q.rear+1)%MAXSIZE==Q.front</code>    </p><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status InitQueue(SqQueue &amp;Q)    //初始化</span><br><span class="line">&#123;</span><br><span class="line">    Q.base=new ElemType[MAXSIZE];   //Q.base指向数组空间的首地址</span><br><span class="line">    if(!Q.base) return ERROR;</span><br><span class="line">    Q.front=Q.rear=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p><strong>求队列长度</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status QueueLength(SqQueue Q)    //队列的长度</span><br><span class="line">&#123;</span><br><span class="line">    return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>入队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status EnQueue(SqQueue &amp;Q,ElemType e)    //进队列</span><br><span class="line">&#123;</span><br><span class="line">    if((Q.rear+1)%MAXSIZE==Q.front)</span><br><span class="line">        return ERROR;</span><br><span class="line">    Q.base[Q.rear]=e;</span><br><span class="line">    Q.rear=(Q.rear+1)%MAXSIZE;     //队尾指针加1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>出队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status DeQueue(SqQueue &amp;Q,ElemType &amp;e)    //出队列</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.rear==Q.front) return ERROR;</span><br><span class="line">    e=Q.base[Q.front];</span><br><span class="line">    Q.front=(Q.front+1)%MAXSIZE;    //队头指针加1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取队头元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElemType GetHead(SqQueue Q)     //获取队列头元素</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front!=Q.rear)</span><br><span class="line">        return Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="链队—队列的链式表示和实现"><a href="#链队—队列的链式表示和实现" class="headerlink" title="链队—队列的链式表示和实现"></a>链队—队列的链式表示和实现</h4><ul><li><strong>链队的初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct QNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>一个链队显然需要两个分别指向队头和队尾的指针才能确定；<br>这里为操作方便，给链队添加一个头结点，并令头指针指向头结点；    </p><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status InitQueue(LinkQueue &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front=Q.rear=new QNode;</span><br><span class="line">    Q.front-&gt;next=NULL;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p><strong>链队的入队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status EnQueue(LinkQueue &amp;Q,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    QNode *p;</span><br><span class="line">    p=new QNode;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=NULL;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链队的出队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status DeQueue(LinkQueue &amp;Q,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front==Q.rear) return ERROR;</span><br><span class="line">    QNode *p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    if(Q.rear==p) Q.rear=Q.front;</span><br><span class="line">        delete p;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取队头元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElemType GetHead(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front!=Q.rear)</span><br><span class="line">        return Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（2）——线性表</title>
      <link href="/2018/09/08/2018-09-08-data-struct-summary-2/"/>
      <url>/2018/09/08/2018-09-08-data-struct-summary-2/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><p><strong>线性表</strong>：由n（n≥0）个数据特性相同的元素构成的有限序列。<br>特点：<br>① 存在唯一的一个被称为“第一个”的数据元素；<br>② 存在唯一的一个被称为“最后一个”的数据元素；<br>③ 除第一个之外，结构中的每个数据元素均只有一个前驱；<br>④ 出最后一个之外，结构中的每个数据元素均只有一个后继。    </p><h3 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h3><p>ADT List{<br>            数据对象：D＝{ ai | ai ∈ElemSet, i=1,2,…,n,  n≥0 }<br>            数据关系：R1＝{ <ai-1 ,ai>|ai-1 ,ai∈D,  i=2,…,n } i是位序<br>            基本操作：<br>            InitList(&amp;L){构造空的线性表L}<br>            Destroy（&amp;L）{销毁}<br>            ListEmpty（L）{若L为空 返回TRUE}<br>            ListLength（L）{返回L中的元素个数，即表长}<br>            PriorElem（L,cur_e,&amp;pre_e）{cur_e为一个元素且不是第一个，则用pre_e返回它的前驱}<br>            NextElem（L,cur_e,&amp;next_e）<br>            GetElem(L,i,&amp;e){用e返回L中第i个元素的值}<br>            LocateElem（L,e,compare()）{返回L中第一个与e满足compare()的元素位序，否则返回0}<br>            ListTraverse（L,visit()）{依次对L的每个元素调用visit()函数}<br>            ClearList（&amp;L）{置空}<br>            PutElem（&amp;L，i,e）{把e覆盖第i个位置，是改变元素，不是插入}<br>            ListInsert（&amp;L,i,e）{插入的位置是i的前面}<br>            ListDelete(&amp;L,i,&amp;)<br>}ADT List     </ai-1></p><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><h4 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h4><p>线性表的顺序存储表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，通常也称这种存储结构额线性表为顺序表。<br>只要确定了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。    </p><blockquote><p>由于线性表的长度可变，且所需最大的存储空间随问题不同而不同，则在C语言中可用动态分配的一维数组表示线性表。    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//---顺序表的存储结构---    </span><br><span class="line">#define MAXSIZE 100    //顺序表可能达到的最大长度    </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">&amp;nbsp;&amp;nbsp;ElemType *elem;    //存储空间的基地址，ElemType可由用户自定义</span><br><span class="line">&amp;nbsp;&amp;nbsp;int length;    //当前长度</span><br><span class="line">&#125;SqList;    //顺序表的结构类型为SqList</span><br></pre></td></tr></table></figure><p>案例一：多项式的顺序存储结构类型定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 100    //顺序表可能达到的最大长度    </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">&amp;nbsp;&amp;nbsp;float coef;    //系数</span><br><span class="line">&amp;nbsp;&amp;nbsp;float expn;    //指数</span><br><span class="line">&#125;Polynomial;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">&amp;nbsp;&amp;nbsp;Polynomial *elem;    //存储空间的基地址，Polynomial由用户自定义</span><br><span class="line">&amp;nbsp;&amp;nbsp;int length;    //当前长度</span><br><span class="line">&#125;SqList;    //顺序表的结构类型为SqList</span><br></pre></td></tr></table></figure></p><p>案例二：图书数据的顺序存储结构类型定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 10000    //图书表可能达到的最大长度    </span><br><span class="line">typedef struct    //图书信息定义</span><br><span class="line">&#123;</span><br><span class="line">  char no[20];    //图书ISBN</span><br><span class="line">  char name[50];  //图书名字</span><br><span class="line">&#125;Book;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Book *elem;    //存储空间的基地址，Book由用户自定义</span><br><span class="line">  int length;    //当前长度</span><br><span class="line">&#125;SqList;    //顺序表的结构类型为SqList</span><br></pre></td></tr></table></figure></p><p>在上述定以后，可通过变量定义语句<code>SqList L;</code>将L定义成SqList类型的变量；<br>使用<code>L.elem[i-1]</code>访问序号为i的图书记录。    </p><h4 id="顺序表中基本操作的实现"><a href="#顺序表中基本操作的实现" class="headerlink" title="顺序表中基本操作的实现"></a>顺序表中基本操作的实现</h4><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList *L)&#123;    //构造一个空的顺序表L</span><br><span class="line">    L-&gt; elem=new ElemType[MAXSIZE];   //为顺序表分配空间</span><br><span class="line">    if(! L-&gt; elem) exit(OVERFLOW);       //存储分配失败</span><br><span class="line">    L-&gt; length=0;              //空表长度为0</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList *L)&#123;    //构造一个空的顺序表L</span><br><span class="line">    L.elem=new ElemType[MAXSIZE];   //为顺序表分配空间</span><br><span class="line">    if(! L.elem) exit(OVERFLOW);       //存储分配失败</span><br><span class="line">    L.length=0;              //空表长度为0</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><strong>销毁</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DestroyList(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">  if (L.elem) delete[]L.elem;    //释放存储空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>清空</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void ClearList(SqList &amp;L) </span><br><span class="line">&#123;</span><br><span class="line">   L.length=0;                //将线性表的长度置为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线性表长度</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int GetLength(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">   return (L.length);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断线性表是否为空</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int IsEmpty(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">  if (L.length==0) return 1;      </span><br><span class="line">   else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取值</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//根据指定位置，获取相应位置数据元素的内容</span><br><span class="line">int GetElem(SqList L,int i,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">  if (i&lt;1||i&gt;L.length) return ERROR;   </span><br><span class="line">   //判断i值是否合理，若不合理，返回ERROR</span><br><span class="line">  e=L.elem[i-1];   //第i-1的单元存储着第i个数据</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>查找</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int LocateELem(SqList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">  for (i=0;i&lt; L.length;i++)</span><br><span class="line">      if (L.elem[i]==e) return i+1;                </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_Sq(SqList &amp;L,int i ,ElemType e)&#123;</span><br><span class="line">   if(i&lt;1 || i&gt;L.length+1) return ERROR;         //i值不合法</span><br><span class="line">   if(L.length==MAXSIZE) return ERROR;    //当前存储空间已满     </span><br><span class="line">   for(j=L.length-1;j&gt;=i-1;j--) </span><br><span class="line">       L.elem[j+1]=L.elem[j];    //插入位置及之后的元素后移</span><br><span class="line">    L.elem[i-1]=e;                     //将新元素e放入第i个位置</span><br><span class="line">  ++L.length;     //表长增1</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">   if((i&lt;1)||(i&gt;L.length)) return ERROR; //i值不合法</span><br><span class="line">   e=L.elem[i-1];                              //将欲删除的元素保留在e中</span><br><span class="line">  for (j=i;j&lt;=L.length-1;j++)                   </span><br><span class="line">　  　L.elem[j-1]=L.elem[j];       //被删除元素之后的元素前移  </span><br><span class="line">   --L.length;                     //表长减1</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><h4 id="单链表的定义和表示"><a href="#单链表的定义和表示" class="headerlink" title="单链表的定义和表示"></a>单链表的定义和表示</h4><ul><li><strong>结点</strong>：存储本身的信息以及存储指示其后继信息的存储映像；</li><li><strong>数据域</strong>：存储数据元素信息的域称为数据域；</li><li><strong>指针域</strong>：存储直接后继存储位置的域；</li><li>n个结点链接成一个链表，又由于此链表的每个结点只包含一个指针域，故又称<strong>线性链表</strong>或<strong>单链表</strong>；</li><li>链表分为：单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表；</li><li>其中单链表、循环链表和双向链表用于实现线性表的链式存储，其他形式多用于实现树和图等非线性结构；</li><li>单链表时非随机存取的存储结构，取第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存取结构。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//---单链表的存储结构---</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">     ElemType   data;       //数据域</span><br><span class="line">     struct LNode  *next;   //指针域</span><br><span class="line">&#125;LNode,*LinkList;   // *LinkList为Lnode类型的指针</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>LinkList与LNode<em>本质上是等价的。通常使用LinkList定义单链表，强调定义的是某个单链表的头指针；<br>用LNode</em>定义指向单链表中任一结点的指针变量。<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%B4%E6%8C%87%E9%92%88%E5%A4%B4%E7%BB%93%E7%82%B9%E9%A6%96%E5%85%83%E7%BB%93%E7%82%B9.png" alt="头指针头节点首元结点">    </p></blockquote><p>链表增加头结点的作用：<br>（1）便于首元结点的处理：首元结点地址保存在头结点的指针域中，使其和其他数据元素操作一样；<br>（2）便于空表和非空表的统一处理：当不设头结点时，假设L为单链表的头指针，则当单链表的长度n为0的空表时，L指针为空（L==NULL）；当增加头结点后，无论链表是否为空，头指针都是指向头结点的非空结点，即若为空表，头结点的指针域为空（L-&gt;next==NULL)；    </p><h4 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h4><ul><li><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_L(LinkList &amp;L)&#123; </span><br><span class="line">   L=new LNode;                    </span><br><span class="line">   L-&gt;next=NULL;　　　　　</span><br><span class="line">   return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status DestroyList_L(LinkList &amp;L)&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">       while(L)</span><br><span class="line">        &#123;</span><br><span class="line">            p=L;  </span><br><span class="line">            L=L-&gt;next;</span><br><span class="line">            delete p;  </span><br><span class="line">        &#125;</span><br><span class="line">     return OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>清空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ClearList(LinkList &amp; L)&#123;</span><br><span class="line">  // 将L重置为空表 </span><br><span class="line">   LinkList p,q;</span><br><span class="line">   p=L-&gt;next;   //p指向第一个结点</span><br><span class="line">   while(p)       //没到表尾 </span><br><span class="line">      &#123;  q=p-&gt;next; delete p; p=q;   &#125;</span><br><span class="line">   L-&gt;next=NULL;   //头结点指针域为空 </span><br><span class="line">   return OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>求表长</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int  ListLength_L(LinkList L)&#123;</span><br><span class="line">//返回L中数据元素个数</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L-&gt;next;         //p指向第一个结点</span><br><span class="line">     i=0;             </span><br><span class="line">     while(p)&#123;           //遍历单链表,统计结点数</span><br><span class="line">           i++;</span><br><span class="line">           p=p-&gt;next;    &#125; </span><br><span class="line">    return i;                             </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>判断是否为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ListEmpty(LinkList L)&#123; </span><br><span class="line">//若L为空表，则返回1，否则返回0 </span><br><span class="line">   if(L-&gt;next)   //非空 </span><br><span class="line">     return 0;</span><br><span class="line">   else</span><br><span class="line">     return 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem_L(LinkList L,int i,ElemType &amp;e)&#123; </span><br><span class="line">    p=L-&gt;next;j=1; //初始化</span><br><span class="line">     while(p&amp;&amp;j&lt;i)&#123;//向后扫描，直到p指向第i个元素或p为空 </span><br><span class="line">       p=p-&gt;next; ++j; </span><br><span class="line">     &#125; </span><br><span class="line">     if(!p || j&gt;i)return ERROR; //第i个元素不存在 </span><br><span class="line">     e=p-&gt;data; //取第i个元素 </span><br><span class="line">     return OK; </span><br><span class="line">&#125;//GetElem_L</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LNode *LocateELem_L (LinkList L，Elemtype e) &#123; </span><br><span class="line">  p=L-&gt;next; </span><br><span class="line">  while(p &amp;&amp;p-&gt;data!=e)  </span><br><span class="line">        p=p-&gt;next;                </span><br><span class="line">  return p; //返回L中值为e的数据元素的位置，查找失败返回NULL </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L,int i,ElemType e)&#123; </span><br><span class="line">     p=L;j=0; </span><br><span class="line">      while(p&amp;&amp;j&lt;i−1)&#123;p=p-&gt;next;++j;&#125;//寻找第i−1个结点 </span><br><span class="line">      if(!p||j&gt;i−1)return ERROR;//i大于表长 + 1或者小于1  </span><br><span class="line">      s=new LNode;//生成新结点s </span><br><span class="line">      s-&gt;data=e;                 //将结点s的数据域置为e </span><br><span class="line">      s-&gt;next=p-&gt;next;             //将结点s插入L中 </span><br><span class="line">      p-&gt;next=s; </span><br><span class="line">      return OK; </span><br><span class="line">&#125;//ListInsert_L</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">    p=L;j=0; </span><br><span class="line">    while(p-&gt;next &amp;&amp;j&lt;i-1)&#123;//寻找第i个结点，并令p指向其前驱 </span><br><span class="line">        p=p-&gt;next; ++j; </span><br><span class="line">    &#125; </span><br><span class="line">    if(!(p-&gt;next)||j&gt;i-1) return ERROR; //删除位置不合理 </span><br><span class="line">    q=p-&gt;next; //临时保存被删结点的地址以备释放 </span><br><span class="line">    p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域 </span><br><span class="line">    e=q-&gt;data; //保存删除结点的数据域 </span><br><span class="line">    delete q; //释放删除结点的空间 </span><br><span class="line"> return OK; </span><br><span class="line">&#125;//ListDelete_L</span><br></pre></td></tr></table></figure></li><li><p>创建单链表（前插法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_F(LinkList &amp;L,int n)&#123; </span><br><span class="line">     L=new LNode; </span><br><span class="line">      L-&gt;next=NULL; //先建立一个带头结点的单链表 </span><br><span class="line">      for(i=n;i&gt;0;--i)&#123; </span><br><span class="line">        p=new LNode; //生成新结点 </span><br><span class="line">        cin&gt;&gt;p-&gt;data; //输入元素值 </span><br><span class="line">        p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 </span><br><span class="line">     &#125; </span><br><span class="line">&#125;//CreateList_F</span><br></pre></td></tr></table></figure></li><li><p>创建单链表（后插法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_L(LinkList &amp;L,int n)&#123; </span><br><span class="line">      //正位序输入n个元素的值，建立带表头结点的单链表L </span><br><span class="line">      L=new LNode; </span><br><span class="line">      L-&gt;next=NULL; </span><br><span class="line">      r=L; //尾指针r指向头结点 </span><br><span class="line">      for(i=0;i&lt;n;++i)&#123; </span><br><span class="line">        p=new LNode;　//生成新结点 </span><br><span class="line">        cin&gt;&gt;p-&gt;data;   //输入元素值 </span><br><span class="line">        p-&gt;next=NULL; r-&gt;next=p;     //插入到表尾 </span><br><span class="line">        r=p; //r指向新的尾结点 </span><br><span class="line">      &#125; </span><br><span class="line">&#125;//CreateList_L</span><br></pre></td></tr></table></figure></li></ul><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表：最后一个结点的指针域指向头结点，形成一个环，因此从表中任一结点出发均可找到表中其他结点。<br>循环单链表的操作和单链表基本一致，差别在于：当链表遍历时，判别当前指针p是否指向表尾的终止条件不同。在单链表中，判断条件为<code>p!=NULL或p-&gt;next!=NULL</code>再循环单链表中判断条件为<code>p!=L或p-&gt;next!=L</code><br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6.PNG" alt="循环链表的合并"></p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//---双向链表的存储结构---</span><br><span class="line">typedef struct DuLNode&#123;</span><br><span class="line">    ElemType   data;              </span><br><span class="line">    struct DuLNode  *prior;  </span><br><span class="line">    struct DuLNode  *next;  </span><br><span class="line">&#125;DuLNode, *DuLinkList</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.PNG" alt="双向循环链表"></p><ul><li><p>双向链表的插入<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.PNG" alt="双向链表的插入"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e)&#123;</span><br><span class="line">   if(!(p=GetElemP_DuL(L,i))) return ERROR;</span><br><span class="line">    s=new DuLNode; </span><br><span class="line">   s-&gt;data=e;</span><br><span class="line">   s-&gt;prior=p-&gt;prior;  ①</span><br><span class="line">   p-&gt;prior-&gt;next=s;   ②</span><br><span class="line">   s-&gt;next=p;          ③</span><br><span class="line">   p-&gt;prior=s;         ④</span><br><span class="line">   return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双向链表的删除<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4.PNG" alt="双向链表的删除"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_DuL(DuLinkList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">   if(!(p=GetElemP_DuL(L,i)))     return ERROR;</span><br><span class="line">   e=p-&gt;data;</span><br><span class="line">   p-&gt;prior-&gt;next=p-&gt;next;     ①</span><br><span class="line">   p-&gt;next-&gt;prior=p-&gt;prior;    ②</span><br><span class="line">   delete p; </span><br><span class="line">   return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单算法实现</title>
      <link href="/2018/09/08/2018-09-08-Algorithm-demo/"/>
      <url>/2018/09/08/2018-09-08-Algorithm-demo/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="复数抽象数据类型的定义及操作"><a href="#复数抽象数据类型的定义及操作" class="headerlink" title="复数抽象数据类型的定义及操作"></a>复数抽象数据类型的定义及操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ERROR 0 </span><br><span class="line">typedef float status;</span><br><span class="line"></span><br><span class="line">typedef struct    //抽象数据类型的存储结构</span><br><span class="line">&#123;</span><br><span class="line">    float Realpart;</span><br><span class="line">    float Imagepart;</span><br><span class="line">&#125;Complex;</span><br><span class="line"></span><br><span class="line">void Create(Complex &amp;C,float x,float y)   //构建复数</span><br><span class="line">&#123;</span><br><span class="line">    C.Realpart=x;</span><br><span class="line">    C.Imagepart=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status GetReal(Complex C)    //取实部</span><br><span class="line">&#123;</span><br><span class="line">    return C.Realpart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status GetImag(Complex C)    //取虚部</span><br><span class="line">&#123;</span><br><span class="line">    return C.Imagepart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Add(Complex C1,Complex C2)    //复数相加</span><br><span class="line">&#123;</span><br><span class="line">    Complex sum;</span><br><span class="line">    sum.Realpart=C1.Realpart+C2.Realpart;</span><br><span class="line">    sum.Imagepart=C1.Imagepart+C2.Imagepart;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Sub(Complex C1,Complex C2)    //复数相减</span><br><span class="line">&#123;</span><br><span class="line">    Complex dif;</span><br><span class="line">    dif.Realpart=C1.Realpart-C2.Realpart;</span><br><span class="line">    dif.Imagepart=C1.Imagepart-C2.Imagepart;</span><br><span class="line">    return dif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    Complex C1,C2,C3,C4;</span><br><span class="line">    cout&lt;&lt;&quot;请输入第一个复数！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    cin&gt;&gt;C1.Realpart;</span><br><span class="line">    cin&gt;&gt;C1.Imagepart;</span><br><span class="line">    cout&lt;&lt;&quot;请输入第二个复数！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    cin&gt;&gt;C2.Realpart;</span><br><span class="line">    cin&gt;&gt;C2.Imagepart;</span><br><span class="line">    cout&lt;&lt;&quot;C1实部为：&quot;&lt;&lt;GetReal(C1)&lt;&lt;&quot;C1虚部为：&quot;&lt;&lt;GetImag(C1)&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    C3=Add(C1,C2);</span><br><span class="line">    C4=Sub(C1,C2);</span><br><span class="line">    cout&lt;&lt;&quot;和为：&quot;&lt;&lt;C3.Realpart&lt;&lt;&quot;+&quot;&lt;&lt;C3.Imagepart&lt;&lt;&quot;i&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    cout&lt;&lt;&quot;差为：&quot;&lt;&lt;C4.Realpart&lt;&lt;&quot;+&quot;&lt;&lt;C4.Imagepart&lt;&lt;&quot;i&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个有序表的合并（顺序表）"><a href="#两个有序表的合并（顺序表）" class="headerlink" title="两个有序表的合并（顺序表）"></a>两个有序表的合并（顺序表）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OK 1</span><br><span class="line">typedef int status;</span><br><span class="line">typedef int Elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct    //抽象数据类型的存储结构</span><br><span class="line">&#123;</span><br><span class="line">    Elemtype *elem;</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">status initlist(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">L.elem=new Elemtype[MAXSIZE];</span><br><span class="line">if(!L.elem) return ERROR;</span><br><span class="line">L.length=0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqList createlist(int n)</span><br><span class="line">&#123;</span><br><span class="line">SqList L;</span><br><span class="line">initlist(L);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;L.elem[i];</span><br><span class="line">++L.length;</span><br><span class="line">&#125;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(SqList L1,SqList L2,SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">int *p,*p1,*p2,*p1_last,*p2_last;</span><br><span class="line">initlist(L);</span><br><span class="line">L.length=L1.length+L2.length;</span><br><span class="line">p=L.elem;p1=L1.elem;p2=L2.elem;</span><br><span class="line">p1_last=L1.elem+L1.length-1;</span><br><span class="line">p2_last=L2.elem+L2.length-1;</span><br><span class="line">while((p1&lt;=p1_last)&amp;&amp;(p2&lt;=p2_last))</span><br><span class="line">&#123;</span><br><span class="line">    if(*p1&lt;=*p2) *p++=*p1++;</span><br><span class="line">else *p++=*p2++;</span><br><span class="line">&#125;</span><br><span class="line">while(p1&lt;=p1_last) *p++=*p1++;</span><br><span class="line">while(p2&lt;=p2_last) *p++=*p2++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123; </span><br><span class="line">SqList L1,L2,L;</span><br><span class="line">initlist(L1);</span><br><span class="line">initlist(L2);</span><br><span class="line">initlist(L);</span><br><span class="line">cout&lt;&lt;&quot;请输入4个数字！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">L1=createlist(4);</span><br><span class="line">cout&lt;&lt;&quot;请输入3个数字！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">L2=createlist(3);</span><br><span class="line">merge(L1,L2,L);</span><br><span class="line">for(int j=0;j&lt;L.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;L.elem[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序表的合并（单链表）"><a href="#有序表的合并（单链表）" class="headerlink" title="有序表的合并（单链表）"></a>有序表的合并（单链表）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OK 1</span><br><span class="line">typedef int status;</span><br><span class="line">typedef int Elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">    Elemtype data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;LNode,*Linklist;</span><br><span class="line"></span><br><span class="line">status init(Linklist &amp;L)    //链表初始化</span><br><span class="line">&#123; </span><br><span class="line">    L=new LNode;    //为链表开辟内存空间</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void create_L(Linklist &amp;L,int n)     //后插法</span><br><span class="line">&#123;</span><br><span class="line">LNode *p,*r;</span><br><span class="line">L=new LNode;   //开辟内存空间</span><br><span class="line">L-&gt;next=NULL;  //创建一个链表</span><br><span class="line">r=L;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    p=new LNode;    //创建结点</span><br><span class="line">cin&gt;&gt;p-&gt;data;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">r-&gt;next=p;</span><br><span class="line">r=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeList_L(Linklist La,Linklist Lb,Linklist &amp;Lc)&#123;     //合并有序链表</span><br><span class="line">   LNode *pa,*pb,*pc,*a;</span><br><span class="line">   init(Lc);    //******这是必须的！！！</span><br><span class="line">   pa=La-&gt;next;  pb=Lb-&gt;next; </span><br><span class="line">   pc=Lc=La;             //用La的头结点作为Lc的头结点 </span><br><span class="line">   while(pa &amp;&amp; pb)&#123;</span><br><span class="line">      if(pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;&#125;</span><br><span class="line">      else&#123;pc-&gt;next=pb; pc=pb; pb=pb-&gt;next;&#125;</span><br><span class="line">   pc-&gt;next=pa?pa:pb;    //插入剩余段  </span><br><span class="line">   //delete a;             //释放Lb的头结点  </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">LNode *p,*L1,*L2,*L,*p1,*p2;</span><br><span class="line">cout&lt;&lt;&quot;请输入3个数字&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">create_L(L1,3);</span><br><span class="line">cout&lt;&lt;&quot;创建成功！&quot;&lt;&lt;&quot;第一个序列是：&quot;;</span><br><span class="line">p1=L1-&gt;next;</span><br><span class="line">while(p1)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p1-&gt;data;</span><br><span class="line">p1=p1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;请输入4个数字&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">create_L(L2,4);</span><br><span class="line">cout&lt;&lt;&quot;创建成功！&quot;&lt;&lt;&quot;第二个序列是：&quot;;</span><br><span class="line">p2=L2-&gt;next;</span><br><span class="line">while(p2)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p2-&gt;data;</span><br><span class="line">p2=p2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">MergeList_L(L1,L2,L);</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">cout&lt;&lt;&quot;输出为&quot;&lt;&lt;&quot;&quot;;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p-&gt;data;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（1）——绪论</title>
      <link href="/2018/09/07/2018-09-07-data-struct-summary-1/"/>
      <url>/2018/09/07/2018-09-07-data-struct-summary-1/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="数据结构研究内容"><a href="#数据结构研究内容" class="headerlink" title="数据结构研究内容"></a>数据结构研究内容</h3><ul><li><strong>数值计算</strong><br>计算机主要用于数值计算，主要步骤包括：①从具体问题中抽象出数学模型；②设计解决此数学模型的算法；③编写程序，进行调试。<br>寻找数学模型的实质是分析问题，从中提取操作对象，并找出这些操作对象之间的关系，然后用数学语言加以描述，即建立相应的数学方程。    </li><li><strong>非数值计算</strong><br>非数值问题的数学模型不再是数学方程，而是诸如线性表、树和图的数据结构。<br><strong>数据结构是一门研究非数值（抽象数据类型）计算程序设计中的操作对象，以及这些对象之间的关系和操作的学科。</strong>       </li></ul><hr><h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><ul><li><strong>数据</strong><br>所有能输入到计算机中并被计算机程序处理的符号总称；（整数/实数/字符串/图形/声音/动画经特殊编码后的数据）    </li><li><strong>数据元素</strong><br>数据的基本单位，也称元素、记录。数据元素用于完整地描述一个操作对象，如花名单中一名学生记录、树中棋盘的一个状态、图中的一个顶点；    </li><li><strong>数据项</strong><br>组成数据元素的、有独立含义的、不可分割的最小单位。如学生基本信息表中的学号、姓名、性别都是数据项；    </li><li><strong>数据对象</strong><br>性质相同的数据元素的集合，是数据的一个子集。    </li></ul><hr><ul><li>数据结构的<strong>逻辑结构</strong><br>从逻辑上描述数据，与数据的存储无关，可以看作是从具体问题中抽象出来的数学模型。<br>逻辑结构的两个要素：一是数据元素；二是关系。<br>（1）_线性结构_：线性表、栈和队列、字符串、数组、广义表；<br>（2）_非线性结构_：树和二叉树、有向图和无向图。    </li><li>数据结构的<strong>存储结构</strong><br>数据对象在计算机中的存储表示称为数据的存储结构，也称物理结构。<br>将数据对象存储到计算机的时候通常要考虑存储数据元素的数据，又要存储数据元素之间的逻辑关系。<br>存储结构包括：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。    </li></ul><hr><ul><li><strong>抽象数据类型</strong><br>抽象数据类型是指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。<br>具体包括三部分：数据对象、数据对象上关系的集合，以及对数据对象的基本操作的集合。<br>ADT 抽象数据类型名{<br>&nbsp;&nbsp; 数据对象：&lt;数据对象的定义&gt;<br>&nbsp;&nbsp; 数据关系：&lt;数据关系的定义&gt;<br>&nbsp;&nbsp; 基本操作：&lt;基本操作的定义&gt;<br>}ADT&nbsp; 抽象数据类型名<br>基本操作名（参数表）<br>&nbsp;&nbsp; 初始条件：&lt;初始条件描述&gt;<br>&nbsp;&nbsp; 操作结果：&lt;操作结果描述&gt;<br>基本操作有两种参数：<strong>赋值参数</strong>只为操作提供输入值；<strong>引用参数</strong>以”&amp;”打头，既可以提供输入值，还可返回操作结果。         </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用caffe训练数据集</title>
      <link href="/2018/08/24/2018-08-24-caffe-train-data/"/>
      <url>/2018/08/24/2018-08-24-caffe-train-data/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3>（1） 结合Caffe平台，进一步掌握Caffe的使用流程；<br>（2） 进一步理解Caffe卷积神经网络定义和优化思想；<br>（3） 学会使用prototxt定义卷积神经网络和优化方法；<br>（4） 能看懂卷积神经网络的关键代码；<br>（5） 能独立完成卷积神经网络和优化自定义；<br>（6） 运行自己的数据，解决自己在实践或科研过程中要解决的计算机视觉问题。</li></ul><h3 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h3><ul><li>硬件准备：GPU（若使用GPU模式），此选项可选择</li><li>软件准备：Caffe  </li><li>数据准备：自己要识别的数据集<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3>使用Caffe自定义网络结构和优化方案，识别分类自己的数据集。<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4>在网上找大巴车、恐龙、大象、鲜花和马五个图像数据集，编号分别以3,4,5,6,7开头，每个种类100张，其中80张作为训练集，20张作为测试集。因此最终训练图片400张，测试图片100张。<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4>训练集目录：/home/joczu/caffe-master/data/re/train<br>测试集目录：/home/joczu/caffe-master/data/re/val<br>sh文件目录：/home/joczu/caffe-master/examples/myfile<h4 id="预处理（生成标签）"><a href="#预处理（生成标签）" class="headerlink" title="预处理（生成标签）"></a>预处理（生成标签）</h4>编写create_filelist.sh文件，使用<br><pre><code>find $DATA/train -name $i*.jpg | cut -d '/' -f4-5 | sed "s/$/ $i/">>$MY/train.txt</code></pre><br>把每个图片的名称和上级目录名给截取出来，并分别以开头数字3,4,5,6,7作为一个种类的标签。<br><pre><code><h1 id="usr-bin-env-sh"><a href="#usr-bin-env-sh" class="headerlink" title="/usr/bin/env sh"></a>/usr/bin/env sh</h1>DATA1=”/home/joczu/caffe-master/data/re”<br>DATA2=”/home/joczu/caffe-master/data/re/train/cat”<br>DATA3=”/home/joczu/caffe-master/data/re/train/dog”<br>DATA4=”/home/joczu/caffe-master/data/re/val”</code></pre></li></ul><p>echo “Create train.txt…”</p><p>rm -rf $DATA1/train.txt<br>rm -rf $DATA1/val.txt</p><p>find $DATA2 -name Abyssinian<em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 1/“&gt;&gt;$DATA1/train.txt<br>find $DATA3 -name american_bulldog</em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 2/“&gt;&gt;$DATA1/tmp.txt<br>find $DATA4 -name Abyssinian<em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 1/“&gt;&gt;$DATA1/val.txt<br>find $DATA4 -name american_bulldog</em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 2/“&gt;&gt;$DATA1/tmp_val.txt</p><p>cat $DATA1/tmp.txt&gt;&gt;$DATA1/train.txt<br>cat $DATA1/tmp_val.txt&gt;&gt;$DATA1/val.txt<br>rm -rf $DATA1/tmp.txt<br>rm -rf $DATA1/tmp_val.txt</p><p>echo “Done..”<br>&lt;/code&gt;&lt;/pre&gt;</p><h4 id="转换lmdb数据格式"><a href="#转换lmdb数据格式" class="headerlink" title="转换lmdb数据格式"></a>转换lmdb数据格式</h4><p>编写creat_lmdb.sh文件，首先转换图片大小，像素均变化成256X256，再调用build/tools/convert_imageset转换图片的数据格式，生成img_test_lmdb和img_train_lmdb文件</p><p><pre><code></code></pre></p><h1 id="usr-bin-env-sh-1"><a href="#usr-bin-env-sh-1" class="headerlink" title="!/usr/bin/env sh"></a>!/usr/bin/env sh</h1><p>MY=examples/myfile</p><p>echo “Creating train lmdb…”<br>rm -rf $MY/img_train_lmdb<br>build/tools/convert_imageset \<br>—shuffle \<br>—resize_height=256 \<br>—resize_width=256 \</p><h1 id="data-re-train"><a href="#data-re-train" class="headerlink" title="/data/re/train \"></a>/data/re/train \</h1><p>$MY/train.txt \<br>$MY/img_train_lmdb<br>echo “Done.”</p><p>echo “Creating test lmdb..”<br>rm -rf $MY/img_test_lmdb<br>build/tools/convert_imageset \<br>—shuffle \<br>—resize_width=256 \<br>—resize_height=256 \</p><h1 id="data-re-val"><a href="#data-re-val" class="headerlink" title="/data/re/val \"></a>/data/re/val \</h1><p>$MY/val.txt \<br>$MY/img_test_lmdb<br>echo “All Done.”<br>&lt;/code&gt;&lt;/pre&gt;<br>到此数据的预处理完成。</p><h4 id="生成均值文件"><a href="#生成均值文件" class="headerlink" title="生成均值文件"></a>生成均值文件</h4><p>图片减去均值再训练，会提高训练速度和精度。因此，一般都会有这个操作。<br>caffe程序提供了一个计算均值的文件compute_image_mean.cpp，我们直接使用就可以了。<br>compute_image_mean带两个参数，第一个参数是lmdb训练数据位置，第二个参数设定均值文件的名字及保存路径。 运行成功后，会在 examples/myfile/ 下面生成一个mean.binaryproto的均值文件。</p><h4 id="创建训练模型"><a href="#创建训练模型" class="headerlink" title="创建训练模型"></a>创建训练模型</h4><p>模型就用程序自带的caffenet模型，位置在 models/bvlc_reference_caffenet/文件夹下,<br>将需要的两个配置文件，复制到myfile文件夹内，<br>修改其中的solver.prototxt</p><p><pre><code>net: "examples/myfile/train_val.prototxt"test_iter: 2test_interval: 50base_lr: 0.001lr_policy: "step"gamma: 0.1stepsize: 100display: 20max_iter: 200momentum: 0.9weight_decay: 0.005solver_mode: CPUsnapshot: 200snapshot_prefix: "examples/myfile/myfile"</code></pre><br>100个测试数据，batch_size为50，因此test_iter设置为2，就能全cover了。在训练过程中，调整学习率，逐步变小。<br>相关参数解释：<br>_net: “examples/myfile/train_val.prototxt” 网络模型的路径。注意的是：文件的路径要从caffe的根目录开始，其它的所有配置都是这样<br>test_iter: 2 这个要结合layer理解，表示两层；<br>test_interval: 50 测试间隔。也就是每训练50次，才进行一次测试<br>base_lr: 0.001 base_lr用于设置基础学习率，在迭代的过程中，可以对基础学习率进行调整。怎么样进行调整，就是调整的策略，由lr_policy来设置<br>lr_policy: “step” 如果设置为step,则还需要设置一个stepsize, 返回 base_lr * gamma ^ (floor(iter / stepsize)),其中iter表示当前的迭代次数<br>gamma: 0.1 上一次梯度更新的权重<br>stepsize: 100<br>display: 20 每训练２0次，在屏幕上显示一次。如果设置为0，则不显示<br>max_iter: 200 最大迭代次数。这个数设置太小，会导致没有收敛，精确度很低。设置太大，会导致震荡，浪费时间<br>momentum: 0.9 上一次梯度更新的权重<br>weight_decay: 0.005 权重衰减项，防止过拟合的一个参数<br>solver_mode: CPU 设置运行模式。默认为GPU,如果你没有GPU,则需要改成CPU，否则会出错<br>snapshot: 200<br>snapshot_prefix: “examples/myfile/myfile”_<br>修改train_val.protxt，只需要修改两个阶段的data层的文件目录</p><p><pre><code>name: "CaffeNet"layer {  name: "data"  type: "Data"  top: "data"  top: "label"  include {    phase: TRAIN  }  transform_param {    mirror: true    crop_size: 227    mean_file: "data/re/imagenet_mean.binaryproto"  }  data_param {    source: "examples/myfile/imagenet_train_leveldb"    batch_size: 256    backend: LMDB  }}layer {  name: "data"  type: "Data"  top: "data"  top: "label"  include {    phase: TEST  }  transform_param {    mirror: false    crop_size: 227    mean_file: "data/re/imagenet_mean.binaryproto"  }  data_param {    source: "examples/myfile/imagenet_val_leveldb"    batch_size: 20    backend: LMDB  }}</code></pre></p><h4 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h4><p>在caffe根目录下输入以下命令</p><p><pre><code>build/tools/caffe train -solver examples/myfile/solver.prototxt</code></pre><br>接下来就是等待训练完成，训练时间大约需要1.5小时<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/caffe%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C/caffe%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C.png" alt="caffe训练结果"><br>训练到此完成，从结果可以看出训练精度为92％<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/caffe%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C/caffe%E8%AE%AD%E7%BB%83%E7%94%9F%E6%88%90%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6.png" alt="caffe训练生成中间文件"><br>生成许多中间文件。</p><h3 id="实验问题及解决方法"><a href="#实验问题及解决方法" class="headerlink" title="实验问题及解决方法"></a>实验问题及解决方法</h3><p>（1） 本次实验很大的问题就是路径问题，有的地方在使用相对路径的时候需要在caffe-master目录下运行sh文件；<br>（2） 注意训练集、测试集、sh文件放置的相应位置，以免出现不可名状的错误；<br>（3） 注意设置solver.protptxt及train_val.prototxt文件的参数设置，需根据自己的训练集和测试集进行匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> caffe 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割——钢铁表面缺陷检测</title>
      <link href="/2018/08/24/2018-08-24-image-segmentation/"/>
      <url>/2018/08/24/2018-08-24-image-segmentation/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>先对原图进行几何变化（旋转）变成长方形，再对图像进行分割</p><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p><pre><code>clearclcinit=imread('C:\Users\joczu\Desktop\作业3.bmp');%图像旋转G=rgb2gray(init);E=edge(G);theta=1:180;[R,xp]=radon(E,theta);[E,J]=find(R>=max(max(R)));Q=90-J;I=imrotate(G,Q,'bilinear','crop');%图像切割s=I(:,:,1);bw=im2bw(s,graythresh(s));  %graythresh自动找比较合适的阈值se=strel('disk',1);  %创建切割形状bw2=imclose(bw,se);figure(1);imshow(bw2);perim=bwperim(bw2,8); %表示从输入图像BW1中返回只包括对象边缘坐标r=I(:,:,1);%g=I(:,:,2);%b=I(:,:,3);r(perim)=250;%g(perim)=0;%b(perim)=0;I(:,:,1)=r;%I(:,:,2)=g;%I(:,:,3)=b;figure(2);imshow(I);</code></pre></p><h3 id="实验截图"><a href="#实验截图" class="headerlink" title="实验截图"></a>实验截图</h3><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/图像分割-钢铁表面检测/图像分割-钢铁表面检测.png" alt="钢铁表面缺陷分割"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DICOM医学图像处理</title>
      <link href="/2018/08/21/2018-08-21-DICOM-process/"/>
      <url>/2018/08/21/2018-08-21-DICOM-process/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>最大灰度投影（MIP）是临床上最常见的一种血管成像方式，要求将三维数据沿z轴投影。</p><h3 id="实验提示"><a href="#实验提示" class="headerlink" title="实验提示"></a>实验提示</h3><p>将每层DICOM图像对应位置像素点依次比较取最大。</p><h3 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h3><p>MATLAB</p><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p><pre><code>clear allclcclose allfile_path =  'E:\data\'; % 图像文件夹路径  img_path_list = dir(strcat(file_path,'*.dcm'));%获取该文件夹中所有dcm格式的图像  img_num = length(img_path_list);%获取图像总数量  imagemax = img_path_list(1).name;% 图像名imagemax =dicomread(strcat(file_path,imagemax)); %%dcm变成灰度图for w=1:400    for u=1:400        tmp=double(imagemax(w,u));        imagemax(w,u)=uint8(255*(tmp-17)/2407);    endend%%比较        for j = 1:img_num %逐一读取图像              image_name = img_path_list(j).name;% 图像名            image =dicomread(strcat(file_path,image_name));            for c=1:400                for d=1:400                    tem=double(image(c,d));                    image(c,d)=uint8(255*(tem-17)/2407);                end            end            for m=1:400                for n=1:400                    imagemax(m,n)=max(image(m,n),imagemax(m,n));                end            end        end  imshow(imagemax,[]);</code></pre></p><h3 id="实验截图"><a href="#实验截图" class="headerlink" title="实验截图"></a>实验截图</h3><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/DICOM%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/DICOM.png" alt="DICOM医学图像"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN 知识点</title>
      <link href="/2018/08/17/2018-08-17-CNN/"/>
      <url>/2018/08/17/2018-08-17-CNN/</url>
      
        <content type="html"><![CDATA[<h3 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h3><p>1、    深度学习中极具代表性的网络结构之一，常用于图像处理，避免对图像复杂的特征提取，可直接输入原始图像；<br><br>2、    传统的神经网络都是采用输入层到隐藏层全连接的方式，这样导致参数量巨大；而CNN通过局部连接、权值共享方式连接来降低权值参数；<br></p><p>3、    局部连接：</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/%E5%B1%80%E9%83%A8%E8%BF%9E%E6%8E%A5.png" alt="全连接与局部连接"></p><p>4、    权值共享：</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/%E6%9D%83%E5%80%BC%E5%85%B1%E4%BA%AB.png" alt="权值共享"></p><p> 10*10个权值参数，也就是卷积核（也称滤波器）的大小。一个卷积核只能提取图像的一种特征，使用不同大小的卷积核可以得到图像的不同映射下的特征，称之为Feature Map。另外偏置参数也是共享的，同一种滤波器共享一个；<br><br>5、    卷积神经网络的核心思想是：局部感受野（local field），权值共享以及时间或者空间亚采样相结合，获取某种程度的位移、尺度、形变不变性；<br><br>6、    经典的CNN结构——LeNet-5网络</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%E7%BD%91%E7%BB%9C.png" alt="LeNet-5网络"></p><p>CNN主要由两种类型的网络层，分别是卷积层和池化/采样层（pooling）。卷积层的作用是提取图像的各种特征；池化层是对原始特征信号进行抽象，从而大幅度减少训练参数，另外还可以减轻模型过拟合的程度。<br><br>卷积层：</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/%E5%8D%B7%E7%A7%AF.png" alt="卷积"></p><p>池化/采样层：<br>通过不变性（平移、旋转、尺度）保留feature maps主要特征，同时减少特征。<br>通常有两种方式包括Max-Pooling（选择Pooling窗口中的最大值作为采样值）和Mean-Pooling（将Pooling窗口中的所有值相加取平均，以平均值作为采样值）</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20C1%E5%8D%B7%E7%A7%AF%E5%B1%82.png" alt="C1"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20S2%E4%B8%8B%E9%87%87%E6%A0%B7%E5%B1%82.png" alt="S2"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20C3%E5%8D%B7%E7%A7%AF%E5%B1%82.png" alt="C3"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20S4%E4%B8%8B%E9%87%87%E6%A0%B7%E5%B1%82.png" alt="S4"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20C5%E5%8D%B7%E7%A7%AF%E5%B1%82.png" alt="C5"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20F6.png" alt="F6"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20%E8%BE%93%E5%87%BA%E5%B1%82.png" alt="输出层"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
