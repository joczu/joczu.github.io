<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>凸优化:Jensen不等式-共轭函数-Fenchel不等式</title>
      <link href="/2019/04/27/%E5%87%B8%E4%BC%98%E5%8C%96-Jensen%E4%B8%8D%E7%AD%89%E5%BC%8F-%E5%85%B1%E8%BD%AD%E5%87%BD%E6%95%B0-Fenchel%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <url>/2019/04/27/%E5%87%B8%E4%BC%98%E5%8C%96-Jensen%E4%B8%8D%E7%AD%89%E5%BC%8F-%E5%85%B1%E8%BD%AD%E5%87%BD%E6%95%B0-Fenchel%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h2><p>凸函数的定义：$f(\theta x+(1-\theta)y) \leq \theta f(x)+(1-\theta)f(y)$<br>其含义就是：函数图像在直线下边。</p><h2 id="Jensen不等式"><a href="#Jensen不等式" class="headerlink" title="Jensen不等式"></a>Jensen不等式</h2><p>凸函数定义推广到一般形式，即可得到Jensen不等式，即<br>$\theta_1,…\theta_k\geq0, \theta_1+…+\theta_k=1$时，<br>$f(\theta_1x_1+…+\theta_kx_k) \leq \theta_1f(x_1)+…+\theta_kf(x_k)$</p><p>扩展理解：对于$\theta_1,…\theta_k\geq0, \theta_1+…+\theta_k=1$，如果把$\theta_k$看出$x_k$的概率的话，那$\theta_1x_1+…+\theta_kx_k$就表示x的期望，右边式子就表示$f(x)$的期望，于是上式就可以写成$f(E(x))\leq E(f(x))$，这就是Jensen不等式，注意函数f要满足凸函数。</p><h2 id="共轭函数"><a href="#共轭函数" class="headerlink" title="共轭函数"></a>共轭函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>原函数$f:R^n\to R$共轭函数定义：<br><img src="gonge.png" alt><br>这个式子的意思是：求$xt-f(x)$关于x和y函数在定义域内的上界，将这个上界形成的函数定义为共轭函数。下图红色部分就是上界<br><img src="sub.png" alt></p><ol><li><p>定义式中$f(x)$不一定是凸函数</p></li><li><p>共轭函数一定是凸函数（由图可知）</p></li><li><p>凸函数的共轭函数的共轭函数是其本身</p></li></ol><h3 id="如何求共轭函数"><a href="#如何求共轭函数" class="headerlink" title="如何求共轭函数"></a>如何求共轭函数</h3><p><img src="fan.png" alt></p><h2 id="Fenchel不等式"><a href="#Fenchel不等式" class="headerlink" title="Fenchel不等式"></a>Fenchel不等式</h2><p>由共轭函数定义可知，$f^<em>(t) \geq xt-f(x)$ 移项可得 $f(x)+f^</em>(t) \geq xt$ 这就是Fenchel不等式。</p>]]></content>
      
      
      <categories>
          
          <category> 凸优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jensen不等式 </tag>
            
            <tag> 共轭函数 </tag>
            
            <tag> Fenchel不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improving GAN</title>
      <link href="/2019/04/27/Improving-GAN/"/>
      <url>/2019/04/27/Improving-GAN/</url>
      
        <content type="html"><![CDATA[<p>本文对GAN进行更加深入的探讨，主要参考<a href="https://www.bilibili.com/video/av9770302/?p=16" target="_blank" rel="noopener">哔哩哔哩-李宏毅深度学习2017</a>视频的讲解。</p><h2 id="1-统一架构-FGAN"><a href="#1-统一架构-FGAN" class="headerlink" title="1. 统一架构-FGAN"></a>1. 统一架构-FGAN</h2><h3 id="1-1-f-divergence"><a href="#1-1-f-divergence" class="headerlink" title="1.1 f-divergence"></a>1.1 f-divergence</h3><p>这一章节是为了说明GAN中描述$P_G$和$P_{data}$两个分布差异不一定非要用JS divergence，还有其他的divergence可以替代。</p><p><img src="f.png" alt></p><p>其中P和Q表示两个分布，$p(x)$和$q(x)$是采样出来的x的可能性。f是一个凸函数，并且其极值是$f(1)=0$，$D_f(P||Q)$衡量PQ两个分布之间的差异。<br>如果$p(x)=q(x)$，代入等式可得$D_f(P||Q)=0$；<br>当$p(x)!=q(x)$，$D_f(P||Q) \geq f(\int \limits_xq(x) \frac {p(x)}{q(x)})=f(x)=0$<br>当P和Q两个同分布时，$D_f(P||Q)$有最小值0。</p><p>当然f函数可以取很多形式，如下所示<br><img src="fall.png" alt></p><h3 id="1-2-Fenchel-Conjugate"><a href="#1-2-Fenchel-Conjugate" class="headerlink" title="1.2 Fenchel Conjugate"></a>1.2 Fenchel Conjugate</h3><p>细节内容见<a href="/2019/04/27/凸优化-Jensen不等式-共轭函数-Fenchel不等式/" title="凸优化:Jensen不等式-共轭函数-Fenchel不等式">凸优化:Jensen不等式-共轭函数-Fenchel不等式</a></p><p><img src="fc.png" alt></p><p><img src="fc2.png" alt></p><p><img src="fc3.png" alt></p><p><img src="fc4.png" alt></p><h2 id="2-WGAN"><a href="#2-WGAN" class="headerlink" title="2. WGAN"></a>2. WGAN</h2><p>对于传统的GAN来说，选定特定的Divergence度量函数之后，就开始训练使得两个分布的差异尽可能接近。但是使用f-Divergence也会有很多的问题，比如最严重的问题就是当两个分布之间完全没有重叠时，分布间距离的大小并不会直接体现在Divergence 上，这对于基于迭代的优化算法是致命的。<br>WGAN与传统的GAN却别就是度量分布差异的方式不用，WGAN使用Earth mover’s distance（EMD），顾名思义就是把一个分布变成另一个分布需要花费的最小力气。</p><h3 id="Earth-Mover’s-Distance"><a href="#Earth-Mover’s-Distance" class="headerlink" title="Earth Mover’s Distance"></a>Earth Mover’s Distance</h3><p><img src="emd.png" alt></p><p>如上图图所示，如何把P分布经过’搬运’变成Q分布，并且使得’搬运’的代价最小，显然有很多方法取移动，那么如何评估’搬运’的代价大小呢，方法很多，如果我们假定衡量代价大小的标准是”移动的数量”或者”移动的平均距离”那么这两个移动方案肯定能分出优劣的。</p><p><img src="emd2.png" alt></p><p>当我们用分布$Q$上不同颜色的色块对应$P$的相应位置，就可以将最好的移动方案化成上面的样子。为了便于形式化定义，我们将这个变化画成一个矩阵，如下图：</p><p><img src="plan.png" alt></p><p>矩阵内的红色色块代表从$P$分布到$Q$分布对应位置’搬运’的量。<br>$\gamma$’搬运’方法的平均移动距离表示为：</p><script type="math/tex; mode=display">B(\gamma )=\sum \limits_{x_p,x_q} \gamma (x_p,x_q)||x_p-x_q||</script><p>Earth Mover’s Distance指的是上述所有方案中平均移动距离最小的那个方案：</p><script type="math/tex; mode=display">W(P,Q)=\min \limits_{\gamma}B(\gamma)</script><p>为什么可以说EMD的方法比JSD的方法好呢，我们可以从下面的图可以看出：<br><img src="bijiao.png" alt><br>在前50轮训练中，JSD的值一直是$log2$，不能很好的衡量两个分布的差异；而EMD的值可以一直的变化，这样收敛的速度就相对较快了。</p><h3 id="Related-to-GAN"><a href="#Related-to-GAN" class="headerlink" title="Related to GAN"></a>Related to GAN</h3><p>由上节内容知 F-Divergence定义为：<br>$D_f(P_{data}||P_G) = \max \limits_{D} \lbrace E_{x\sim P_{data}}[D(x)]-E_{x \sim P_{G}}[f^*(D(x))] \rbrace$<br>EMD也可以类似的表示出来：<br>$W(P_{data},P_G)=\max \limits_{x \sim 1-Lipschitz} \lbrace E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)] \rbrace$<br>公式中$1-Lipschitz$表示一个函数集，当$f$是一个Lipschitz函数时，它应该满足$||f(x_1)-f(x_2)||\leq K||x_1-x_2||$。当$K=1$时，这个函数就是$1-Lipschitz$函数，直观来说，这个限制是为了让函数的变化更加缓慢一些。如下图所示，绿色的线属于$1-Lipschitz$函数，而蓝色的线不是。<br><img src="lip.png" alt></p><p>为什么要限制生成器D是$1-Lipschitz$函数呢，我们来分析一下当D不是$1-Lipschitz$函数时的情况。<br>我们假设有两个一维分布，$x_1$和$x_2$的距离是$d$，显然他们之间的EMD也是$d$<br><img src="d.png" alt><br>此时我们优化$W(P_{data},P_G)=\max \limits_D \lbrace E_{x \sim P_{data}}[D(x)]-E_{x \sim P_G}[D(x)] \rbrace$时，只需要$D(x_1)=+\infty$，$D(x_2)=-\infty$即可，这样判别器的区分能力太强了，训练起来很困难，很难驱使生成器提高生成分布数据质量。</p><p>如果我们加上$||D(x_1)-D(x_2)|| \leq ||x_1-x_2||=d$的限制，如果我们想要满足上面的优化目标，就可以让$D(x_1)=k+d,D(x_2)=k$，其中$k$具体是什么无所谓，关键是我们通过$d$将判别器在不同分布上的结果限制在了一个较小的范围。</p><p>这样做有什么好处呢？因为传统GAN的判别器是一个最终经过sigmoid函数输出的神经网络，它输出的曲线是S型的，在真实分布附近是1，在生成分布附近是0。当我们加上$||D(x_1)-D(x_2)|| \leq ||x_1-x_2||=d$的限制时，判别器最后一层就不再需要sigmoid函数。<br><img src="sig.png" alt><br>传统的判别器有饱和区（靠近真实和生成分布的地方，函数变化平缓，梯度趋于0），经过限制之后，输出成为了一条直线，训练过程得到加快。</p><blockquote><ol><li>判别器输出层不需再用sigmoid函数</li><li>换成受限的$1-Lipschitz$来实现类似sigmoid的范围限制功能</li><li>生成器和判别器的Loss不需再取log（因为换了Divergence方式）</li></ol></blockquote><p>如何对判别器网络添加$1-Lipschitz$的限制呢？文章中采用简单暴力的方法：截取权重，将权重限制到$[-c,c]$之间，这样限制变成了$K-Lipschitz$，如何调整$K$，只能靠多次调试了。<br><img src="clip.png" alt><br>图中斜率比较陡峭的就是没有截断的函数，截断之后函数会逆时针旋转，产生$1-Lipschitz$的效果。</p><p>原始的GAN算法流程如下：<br><img src="gan.png" alt><br>WGAN的算法如下：<br><img src="wgan.png" alt></p><h2 id="改进WGAN"><a href="#改进WGAN" class="headerlink" title="改进WGAN"></a>改进WGAN</h2>]]></content>
      
      
      <categories>
          
          <category> GAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> KL </tag>
            
            <tag> JSD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo填坑</title>
      <link href="/2019/04/26/Hexo%E5%A1%AB%E5%9D%91/"/>
      <url>/2019/04/26/Hexo%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul><li>创建Hexo工程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><p>此处blog可以替换成你想要的名字。</p><ul><li>新建博文</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd blog</span><br><span class="line">$ hexo new &apos;blog-name&apos;</span><br></pre></td></tr></table></figure><p>此时会在/blog/sources/_post/目录下生成’blog-name.md’文件和’blog-name’的文件夹。md文件用于编辑博文，文件夹用于存放此博文内容照片。</p><ul><li>运行服务器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>本地访问<a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>，查看Hexo网站。</p><ul><li>生成上传至GitHub</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><ul><li>安装主题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /blog/themes</span><br><span class="line">$ git clone https://github.com/wuchong/jacman.git ./jacman</span><br><span class="line">$ cd ./jacman</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>然后修改站点配置文件/blog/config.yml，将其中的theme改成jacman</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: jacman</span><br></pre></td></tr></table></figure><ul><li>LaTex数学公式渲染</li></ul><p>先把node_modules文件夹下的渲染器删掉，再输入下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ul><li>插入图片</li></ul><p>将照片放在与博文同名的文件夹下面，在博文中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](pic.png)</span><br></pre></td></tr></table></figure><p>即可饮用，但是这种方法不能改变图片大小，可采用下面命令修改图片大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&apos;pic.png&apos; width = &apos;80%&apos; height = &apos;80%&apos; &gt;</span><br></pre></td></tr></table></figure><ul><li>文件下载链接</li></ul><p>在blog/sources/files内放入上传的文件，在博文中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](/files/filename)</span><br></pre></td></tr></table></figure><h2 id="LaTex公式编辑"><a href="#LaTex公式编辑" class="headerlink" title="LaTex公式编辑"></a>LaTex公式编辑</h2><ul><li>插入数学公式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$数学公式$ 或者 $$数学公式$$</span><br></pre></td></tr></table></figure><p>前者是行内公式，后者是行间公式</p><ul><li>区块引用</li></ul><p><code>&gt;</code>后面书写引用</p><ul><li><p>分割线</p><p><code>***</code>或者<code>---</code></p></li><li><p>上下标</p></li></ul><p>使用^表示上标，表示下标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x^2 </span><br><span class="line">x_&#123;1,2...,n&#125;</span><br><span class="line">\sum \limits^n \limits_&#123;i=1&#125;</span><br><span class="line">\hat x              //字母上加^</span><br><span class="line">$\overline x$       //字母上加横线 </span><br><span class="line">$\widetilde x$      //字母上加波浪线</span><br><span class="line">$\dot&#123;x&#125;$           //字母上加一个点 </span><br><span class="line">$\ddot&#123;x&#125;$          //字母上加两个点</span><br></pre></td></tr></table></figure><ul><li>波浪线</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\sim</span><br></pre></td></tr></table></figure><ul><li>公式换行对齐</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;split&#125;</span><br><span class="line">y &amp;= a(x + b) \\&amp;= ax+ab  </span><br><span class="line">\end&#123;split&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><ul><li>括号</li></ul><p><code>()</code>和<code>[]</code>都表示它们自己，但是<code>{}</code>因为有特殊作用需要用<code>\lbrace \rbrece</code>表示。</p><ul><li>分数</li></ul><p><code>\frac{分母}{分子}</code>来表示分数</p><ul><li>开方</li></ul><p><code>\sqrt[次数][被开方数]</code>来表示开方</p><ul><li>求期望</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\mathbb&#123;E&#125;</span><br></pre></td></tr></table></figure><ul><li>正负无穷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+\infty</span><br><span class="line">-\infty</span><br></pre></td></tr></table></figure><ul><li>希腊字母</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">大写</th><th style="text-align:center">代码</th><th style="text-align:left">小写</th></tr></thead><tbody><tr><td style="text-align:center"><code>A</code></td><td style="text-align:center">$A$</td><td style="text-align:center"><code>\alpha</code></td><td style="text-align:left">$\alpha$</td></tr><tr><td style="text-align:center"><code>B</code></td><td style="text-align:center">$B$</td><td style="text-align:center"><code>\beta</code></td><td style="text-align:left">$\beta$</td></tr><tr><td style="text-align:center"><code>\Gamma</code></td><td style="text-align:center">$\Gamma$</td><td style="text-align:center"><code>\gamma</code></td><td style="text-align:left">$\gamma$</td></tr><tr><td style="text-align:center"><code>\Delta</code></td><td style="text-align:center">$\Delta$</td><td style="text-align:center"><code>\delta</code></td><td style="text-align:left">$\delta$</td></tr><tr><td style="text-align:center"><code>E</code></td><td style="text-align:center">$E$</td><td style="text-align:center"><code>\epsilon</code></td><td style="text-align:left">$\epsilon$</td></tr><tr><td style="text-align:center"><code>Z</code></td><td style="text-align:center">$Z$</td><td style="text-align:center"><code>\zeta</code></td><td style="text-align:left">$\zeta$</td></tr><tr><td style="text-align:center"><code>H</code></td><td style="text-align:center">$H$</td><td style="text-align:center"><code>\eta</code></td><td style="text-align:left">$\eta$</td></tr><tr><td style="text-align:center"><code>\Theta</code></td><td style="text-align:center">$\Theta$</td><td style="text-align:center"><code>\theta</code></td><td style="text-align:left">$\theta$</td></tr><tr><td style="text-align:center"><code>I</code></td><td style="text-align:center">$I$</td><td style="text-align:center"><code>\iota</code></td><td style="text-align:left">$\iota$</td></tr><tr><td style="text-align:center"><code>K</code></td><td style="text-align:center">$K$</td><td style="text-align:center"><code>\kappa</code></td><td style="text-align:left">$\kappa$</td></tr><tr><td style="text-align:center"><code>\Lambda</code></td><td style="text-align:center">$\Lambda$</td><td style="text-align:center"><code>\lambda</code></td><td style="text-align:left">$\lambda$</td></tr><tr><td style="text-align:center"><code>M</code></td><td style="text-align:center">$M$</td><td style="text-align:center"><code>\mu</code></td><td style="text-align:left">$\mu$</td></tr><tr><td style="text-align:center"><code>N</code></td><td style="text-align:center">$N$</td><td style="text-align:center"><code>\nu</code></td><td style="text-align:left">$\nu$</td></tr><tr><td style="text-align:center"><code>\Xi</code></td><td style="text-align:center">$\Xi$</td><td style="text-align:center"><code>\xi</code></td><td style="text-align:left">$\xi$</td></tr><tr><td style="text-align:center"><code>O</code></td><td style="text-align:center">$O$</td><td style="text-align:center"><code>\omicron</code></td><td style="text-align:left">$\omicron$</td></tr><tr><td style="text-align:center"><code>\Pi</code></td><td style="text-align:center">$\Pi$</td><td style="text-align:center"><code>\pi</code></td><td style="text-align:left">$\pi$</td></tr><tr><td style="text-align:center"><code>P</code></td><td style="text-align:center">$P$</td><td style="text-align:center"><code>\rho</code></td><td style="text-align:left">$\rho$</td></tr><tr><td style="text-align:center"><code>\Sigma</code></td><td style="text-align:center">$\Sigma$</td><td style="text-align:center"><code>\sigma</code></td><td style="text-align:left">$\sigma$</td></tr><tr><td style="text-align:center"><code>T</code></td><td style="text-align:center">$T$</td><td style="text-align:center"><code>\tau</code></td><td style="text-align:left">$\tau$</td></tr><tr><td style="text-align:center"><code>\Upsilon</code></td><td style="text-align:center">$\Upsilon$</td><td style="text-align:center"><code>\upsilon</code></td><td style="text-align:left">$\upsilon$</td></tr><tr><td style="text-align:center"><code>\Phi</code></td><td style="text-align:center">$\Phi$</td><td style="text-align:center"><code>\phi</code></td><td style="text-align:left">$\phi$</td></tr><tr><td style="text-align:center"><code>X</code></td><td style="text-align:center">$X$</td><td style="text-align:center"><code>\chi</code></td><td style="text-align:left">$\chi$</td></tr><tr><td style="text-align:center"><code>\Psi</code></td><td style="text-align:center">$\Psi$</td><td style="text-align:center"><code>\psi</code></td><td style="text-align:left">$\psi$</td></tr><tr><td style="text-align:center"><code>\Omega</code></td><td style="text-align:center">$\Omega$</td><td style="text-align:center"><code>\omega</code></td><td style="text-align:left">$\omega$</td></tr></tbody></table></div><ul><li><p>其他字符</p><ul><li>关系运算符</li></ul><p>|     符号     | 代码         |<br>| :—————: | :—————- |<br>|    $\pm$     | <code>\pm</code>        |<br>|   $\times$   | <code>\times</code>     |<br>|    $\div$    | <code>\div</code>       |<br>|    $\mid$    | <code>\mid</code>       |<br>|   $\nmid$    | <code>\nmid</code>      |<br>|   $\cdot$    | <code>\cdot</code>      |<br>|   $\circ$    | <code>\circ</code>      |<br>|    $\ast$    | <code>\ast</code>       |<br>|  $\bigodot$  | <code>\bigodot</code>   |<br>| $\bigotimes$ | <code>\bigotimes</code> |<br>| $\bigoplus$  | <code>\bigoplus</code>  |<br>|    $\leq$    | <code>\leq</code>       |<br>|    $\geq$    | <code>\geq</code>       |<br>|    $\neq$    | <code>\neq</code>       |<br>|  $\approx$   | <code>\approx</code>    |<br>|   $\equiv$   | <code>\equiv</code>     |<br>|    $\sum$    | <code>\sum</code>       |<br>|   $\prod$    | <code>\prod</code>      |<br>|  $\coprod$   | <code>\coprod</code>    |</p><ul><li>集合运算符</li></ul><p>|    符号     | 代码        |<br>| :————-: | :————— |<br>| $\emptyset$ | <code>\emptyset</code> |<br>|    $\in$    | <code>\in</code>       |<br>|  $\notin$   | <code>\notin</code>    |<br>|  $\subset$  | <code>\subset</code>   |<br>|  $\supset$  | <code>\supset</code>   |<br>| $\subseteq$ | <code>\subseteq</code> |<br>| $\supseteq$ | <code>\supseteq</code> |<br>|  $\bigcap$  | <code>\bigcap</code>   |<br>|  $\bigcup$  | <code>\bigcup</code>   |<br>|  $\bigvee$  | <code>\bigvee</code>   |<br>| $\bigwedge$ | <code>\bigwedge</code> |<br>| $\biguplus$ | <code>\biguplus</code> |<br>| $\bigsqcup$ | <code>\bigsqcup</code> |</p><ul><li>对数运算符</li></ul><p>|  符号  | 代码   |<br>| :——: | :——- |<br>| $\log$ | <code>\log</code> |<br>| $\lg$  | <code>\lg</code>  |<br>| $\ln$  | <code>\ln</code>  |</p><ul><li>三角运算符</li></ul><p>|   符号   | 代码     |<br>| :———: | :———- |<br>|  $\bot$  | <code>\bot</code>   |<br>| $\angle$ | <code>\angle</code> |<br>|  $\sin$  | <code>\sin</code>   |<br>|  $\cos$  | <code>\cos</code>   |<br>|  $\tan$  | <code>\tan</code>   |<br>|  $\cot$  | <code>\cot</code>   |<br>|  $\sec$  | <code>\sec</code>   |<br>|  $\csc$  | <code>\csc</code>   |</p><ul><li>微积分运算符</li></ul><p>|     符号     | 代码         |<br>| :—————: | :—————- |<br>|   $\prime$   | <code>\prime</code>     |<br>|    $\int$    | <code>\int</code>       |<br>|   $\iint$    | <code>\iint</code>      |<br>|   $\iiint$   | <code>\iiint</code>     |<br>|  $\iiiint$   | <code>\iiiint</code>    |<br>|   $\oint$    | <code>\oint</code>      |<br>|    $\lim$    | <code>\lim</code>       |<br>|   $\infty$   | <code>\infty</code>     |<br>|   $\nabla$   | <code>\nabla</code>     |<br>| $\mathrm{d}$ | <code>\mathrm{d}</code> |</p><ul><li>箭头</li></ul><p><img src="jiantou.png" alt></p><ul><li>不常用符号</li></ul><p><img src="buchangyong.png" alt></p><ul><li>非数学符号</li></ul><p><img src="feishuxue.png" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> LaTex </tag>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAN初识</title>
      <link href="/2019/04/25/GAN%E5%88%9D%E8%AF%86/"/>
      <url>/2019/04/25/GAN%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>GAN的相关知识主要是跟着李宏毅老师入门的，具体内容可以访问<a href="https://www.bilibili.com/video/av9770302/?p=15" target="_blank" rel="noopener">哔哩哔哩-李宏毅深度学习2017</a>进行学习。这篇文章主要对学习内容进行总结。</p><h2 id="1-传统生成模型"><a href="#1-传统生成模型" class="headerlink" title="1.传统生成模型"></a>1.传统生成模型</h2><h3 id="AutoEncoder"><a href="#AutoEncoder" class="headerlink" title="AutoEncoder"></a>AutoEncoder</h3><blockquote><p>AutoEncoder是前馈神经网络的一种，曾经重要用于数据的降维或者特征的抽取，而现在也被广泛用于生成模型。与其他前馈神经网络不同的是，其他前馈神经网络关注的是Output Layer和错误率，而AutoEncoder关注点是Hidden Layer；并且普通前馈神经网络一般比较深，而AutoEncoder通常只有一层Hidden Layer。Hidden Layer中神经元组成的向量（Code）用来表示Input</p></blockquote><img src="/2019/04/25/GAN初识/autoencoder.png"><p>如图该模型的作用是生成与原图像相似的图像。将原始图像输入神经网络，经过Encoder的压缩，表示成Code；再经过Decoder的解压生成图像；最后计算生成图像与输入图像的MSE（Mean Square Error），这样就可以对模型进行训练。</p><p><img src="Decoder.png" alt></p><p>若只取AutoEncoder的Decoder部分，随机生成Code向量输入网络进行解码，这样就可以生成图像。</p><p>但是从上图可以看出AutoEncoder的图像生成效果非常的差，从计算loss方式分析其原因。</p><p><img src="7.png" width="40%" height="40%"></p><p>可以从上图中看出，两幅图像仅仅一个像素点的位置不同，但是用MSE计算loss是一样大的，这就说明MSE不能衡量图像像素点的位置信息。</p><p>GAN就出场了，设计了Generator和Discriminator结构进行前馈运算，采用KL/JSD等方式，很好的解决了衡量两个图像分布之间‘difference’的问题。</p><h2 id="2-GAN前馈流程图"><a href="#2-GAN前馈流程图" class="headerlink" title="2.GAN前馈流程图"></a>2.GAN前馈流程图</h2><p><img src="generator.png" width="70%" height="70%"></p><p><img src="discriminator.png" width="25%" height="25%"></p><p>初始化Generator和Discriminator网络参数，服从特定分布的随机变量输入Generator网络生成图像（标签为0），再和真实图像（标签为1）一块输入到Discriminator进行判断。</p><p>若是Discriminator对生成图像的判分较低，则Generator参数进行梯度下降更新（此时固定Discriminator）；再将第二轮Generator生成的图像输入到Discriminator进行判断，若是Discriminator对其判分较高，则更新Discriminator参数。</p><h2 id="3-GAN原理"><a href="#3-GAN原理" class="headerlink" title="3.GAN原理"></a>3.GAN原理</h2><ul><li><h3 id="Maximum-Likelihood-Estimation"><a href="#Maximum-Likelihood-Estimation" class="headerlink" title="Maximum Likelihood Estimation"></a>Maximum Likelihood Estimation</h3></li></ul><p>给定真实数据分布$ P_{data}(x)$，此处的x代表真实图像构成的向量；设生成模型的分布$P_{G}(x;\theta)$，这个生成分布由$\theta$决定，生成图像模型的目标就是使得生成模型分布$P_{G}(x;\theta)$尽可能的接近真实数据分布$ P_{data}(x)$，也就是要计算$\theta$。</p><p>这样就可以采用最大似然估计的方法来，具体方法如下：</p><ol><li>从真实数据分布$ P_{data}(x)$中采样得到${x^1,x^2,…,x^m}$；</li><li>计算每个数据的概率$P_G(x^i;\theta)$</li><li>计算似然：$L = \prod_{i=1}^mP_G(x^i;\theta)$</li><li>求得$\theta$使得似然最大化</li></ol><p><img src="MLE.png" width="75%" height="75%"></p><p>使用最大似然估计求得$\theta$的过程如上图所示，对似然求log变成log似然；真实分布中的所有x的期望等价于概率积分，所以可以转化成积分运算，因为减号之后的积分与$\theta$无关，所以添加上去之后还是等价的；经过这样拼凑之后最大似然估计可以变成求两个分布之间的KL散度，两个分布越相似，KL散度值越小。</p><p>在求$\theta$之前必须要假定生成分布的类型，比如是高斯混合模型，但是在实践中这种假设的效果不太好，所以如何能设计出更加一般化的生成模型分布呢？</p><p>这里采用神经网络来产生生成分布$P_{G}(x;\theta)$，$\theta$也就是神经网络的权重参数。神经网络只要有非线性激活函数，理论上可以去拟合任意函数，概率分布也可以看作是函数映射，所以可以采用神经网络去学习复杂的概率分布。</p><p><img src="GAN%20Distribution.png" width="70%" height="70%"></p><ul><li><p>Generator G</p><p>生成器G是一个函数，输入向量z，输出向量x</p><p>$P_{prior}(z)$表示输入向量z的先验分布，$P_G(x)$由生成器G决定</p></li><li><p>Discriminator D</p><p>判别器D是一个函数，输入向量x，输出标量值</p><p>D用来衡量$P_G(x)$与$P_{data}(x)$之间的不同</p></li><li><p>GAN公式</p><p>$G^*=arg\min\limits_{G}\max\limits_{D}V(G,D)$    </p><p>$V=E_{x \sim P_{data}}[logD(x)]+E_{x \sim P_{G}}[log(1-D(x))]$ 衡量$P_G$与$P_{data}$的不同</p><p>在G一定的情况，寻找D使得$V(G,D)$最大化，也就是对于真实分布中的x，D(x)要接近1，对于生成分布中的x，D(x)要接近于0，这样使得判别器的能力增强；<br>再固定D，寻找G使得$\max\limits_{D}V(G,D)$最小，也就是让来自于生成分布中的x的D(x)尽可能的接近1，这样使得生成器的能力增强。</p></li></ul><p>接下来对$G^*=arg\min\limits_{G}\max\limits_{D}V(G,D)$进行求解。</p><ul><li><h3 id="求解-min-limits-G-max-limits-D-V-G-D"><a href="#求解-min-limits-G-max-limits-D-V-G-D" class="headerlink" title="求解$\min \limits_{G}\max \limits_{D}V(G,D)$"></a>求解$\min \limits_{G}\max \limits_{D}V(G,D)$</h3></li></ul><p>给定G，求得最优的$D^*$使得V最大。</p><p><img src="maxv.png" width="70%" height="70%"></p><p>接下来给定x，求$D^*$使得被积函数取极大值。$P_{data}(x)$和$P_{G}(x)$是已知值，只   需要对D求导即可得到极大值。</p><p><img src="D*.png" width="70%" height="70%"></p><p>将$D^*$代入V式进行整理。</p><p><img src="maxv%E6%8E%A8%E5%AF%BC.png" width="70%" height="70%"></p><p>$log2P_{data}(x)$对x积分之后得$log2$，概率积分为1。</p><p><img src="maxv%E6%8E%A8%E5%AF%BC2.png" width="70%" height="70%"></p><p>上图的推导主要是凑出JSD分布的形式，JS Divergence是KL散度的对称平滑版本，也是描述了两个分布之间的差异。因为JSD值域[0,log2]所以 $\max \limits_DV(G,D)$的取值范围为[-2log2,0]。</p><p>接下来的问题就是如何优化G，使得$P_G(x)$尽可能接近$P_{data}(x)$</p><p><img src="G.png" width="40%" height="40%"></p><p>如上图，将$\max \limits_DV(G,D)$视为损失函数$L(G)$，采用梯度下降的方法进行优化</p><p><img src="G2.png" width="40%" height="40%"></p><h2 id="4-GAN训练"><a href="#4-GAN训练" class="headerlink" title="4.GAN训练"></a>4.GAN训练</h2><p><img src="%E8%AE%AD%E7%BB%83.png" width="65%" height="65%"></p><p>如图所示，在实践训练中，我们不可能求得$P_G$和$P_{data}$的期望，所以只能从真实数据分布和生成数据分布中分别采样，代入到损失函数求的交叉熵。</p><p>具体的算法流程如下</p><p><img src="%E7%AE%97%E6%B3%95.png" width="65%" height="65%"></p><h2 id="5-问题优化"><a href="#5-问题优化" class="headerlink" title="5.问题优化"></a>5.问题优化</h2><ul><li><h3 id="训练初期缓慢"><a href="#训练初期缓慢" class="headerlink" title="训练初期缓慢"></a>训练初期缓慢</h3></li></ul><p><img src="%E7%94%9F%E6%88%90%E5%99%A8%E4%BC%98%E5%8C%96.png" width="25%" height="25%"></p><p>在生成模型的优化过程中，生成器的loss Function是$V=E_{x\sim P_{G}}[-log(1-D(x))]$。如上图所示，当D(x)接近0的时候，梯度非常的小。这就导致在训练的初期，生成器G如果想要骗过判别器D变化是非常的缓慢的。所以就将生成器的loss修改成$V=E_{x\sim P_{G}}[-log(D(x))]$这样可以提高训练的速度。</p><ul><li><h3 id="Loss不变"><a href="#Loss不变" class="headerlink" title="Loss不变"></a>Loss不变</h3></li></ul><p>在实际训练中发现，loss一直不发生变化，即$\max \limits_DV(G,D)=0$</p><p>因为JSD值域是[0,log2]，这也就是说明$P_G$和$P_{data}$没有相似之处，但是实际上两个分布是有相似之处的，出现问题的原因是我们在积分运算中国使用采样的方法，当训练过拟合的时候，D还是能把两部分的点给分开的，如下图所示。</p><p><img src="%E8%BF%87%E6%8B%9F%E5%90%88.png" width="40%" height="40%"></p><p>我们是不是应该让D变得弱一点，减弱它的分类能力，但是我们的初衷是让D变得更强，这就产生了矛盾。</p><p>还有一种原因可能是，两个分布都是高维的，但是两个分布都十分的窄，交集相当的小，这就导致JSD比较大。</p><p>解决方法：添加噪声，让两个分布变得更宽一些，这样可以增大它们之间的交集，在训练过程中，再使噪声逐渐减小。</p><ul><li><h3 id="Mode-Collapse"><a href="#Mode-Collapse" class="headerlink" title="Mode Collapse"></a>Mode Collapse</h3></li></ul><p><img src="mode.png" width="50%" height="50%"></p><p>如上图所示，实际训练过程种可能出现这样的情况，真实的数据分布是双峰分布的，而生成的数据分布只拟合了其中一个峰的分布，也就是说没有学到整个分布。</p><p>造成这种情况的原因是，KL散度中两个分布写反了。</p><p><img src="mode2.png" width="50%" height="50%"></p><p>如上图所示，若是第一KL散度的写法，为了防止出现无穷大，所有有$P_{data}$出现的地方都必须有$P_G$覆盖，这样就不回出现Mode Collapse。</p><h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6.代码"></a>6.代码</h2><p><a href="/files/originGAN.py">GAN代码实现</a></p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7.参考"></a>7.参考</h2><p><a href="https://www.cnblogs.com/bonelee/p/9166084.html" target="_blank" rel="noopener">https://www.cnblogs.com/bonelee/p/9166084.html</a></p>]]></content>
      
      
      <categories>
          
          <category> GAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
            <tag> MLE </tag>
            
            <tag> AutoEncoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/04/14/404/"/>
      <url>/2019/04/14/404/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（4）——串、数组和广义表</title>
      <link href="/2018/09/17/2018-09-17-data-struct-summary-4/"/>
      <url>/2018/09/17/2018-09-17-data-struct-summary-4/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="串的定义、存储结构以及计算"><a href="#串的定义、存储结构以及计算" class="headerlink" title="串的定义、存储结构以及计算"></a>串的定义、存储结构以及计算</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4></li><li>计算机上的非数值处理的对象大部分是字符串数据，字符串一般简称为串。串是一种特殊的线性表，其特殊性体现在数据元素是一个字符；    </li><li>零个字符的串称为空串；只有空格的字符串称为空格串；<h4 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h4>串也有两种基本的存储结构：顺序存储和链式存储，但考虑到存储效率和算法的方便性，串多采用<strong>顺序存储结构</strong>。</li><li>串的顺序存储<blockquote><p>串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。    </p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//---串的定长顺序存储结构---</span><br><span class="line">#define MAXLEN 255    //串的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXLEN+1];</span><br><span class="line">    int length;    //串的当前长度</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//---串的堆式顺序存储结构---</span><br><span class="line">typedef struct&#123;</span><br><span class="line">     char *ch;//若是非空串，则按串长分配存储区，否则为空</span><br><span class="line">     int length;//串的当前长度</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><ul><li>串的链式存储<br>链表的结点可以存放一个字符，也可以存放多个字符，称为结点的大小。链表的最后一个结点不一定全被串值占满，此时通常补上“#”或其他的非串值字符。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//---串的链式存储结构---</span><br><span class="line">#define CHUNKSIZE 80</span><br><span class="line">typedef struct Chunk&#123;    //定义每个结点的存储结构</span><br><span class="line">     char ch[CHUNKSIZE];</span><br><span class="line">     struct Chunk *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">     Chunk *head,*tail;   //串的头和尾指针</span><br><span class="line">     int length;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure></li></ul><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><p>确定主串中所含子串第一次出现的位置（定位）</p><h4 id="BF（Brute-Force）算法"><a href="#BF（Brute-Force）算法" class="headerlink" title="BF（Brute Force）算法"></a>BF（Brute Force）算法</h4><ul><li>算法思想<br>（1）将主串的第pos个字符和模式的第一个字符比较，若相等，继续逐个比较后续字符；若不等，从主串的下一字符起，重新与模式的第一个字符比较；<br>（2）直到主串的一个连续子串字符序列与模式相等 。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功；<br>（3）否则，匹配失败，返回值 0；<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/BF%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B.PNG" alt="BF算法"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int  Index(Sstring S,Sstring T,int pos)&#123;</span><br><span class="line">    i=pos;j=1;</span><br><span class="line">   while (i&lt;=S[0] &amp;&amp; j&lt;=T[0])&#123;</span><br><span class="line">       if (S[i]=T[j]) &#123;++i;++j;&#125;</span><br><span class="line">       else&#123;i=i-j+2;j=1;&#125;</span><br><span class="line">   if (j&gt;T[0])   return i－T[0];</span><br><span class="line">   else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>利用已经<strong>部分匹配</strong>的结果而加快模式串的滑动速度，且主串S的指针i不必回溯！可提速到O(n+m)！<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95%E6%B1%82next%E5%80%BC.PNG" alt="KMP算法求next值"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int Index_KMP(SString S,SString T,int pos,int next[])</span><br><span class="line">&#123; // 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span><br><span class="line">//其中，T非空，1≤pos≤StrLength(S)</span><br><span class="line">int i=pos, j=1;</span><br><span class="line">while (i&lt;=S[0] &amp;&amp; j&lt;=T[0])</span><br><span class="line">if (j==0||S[i]==T[j]) // 继续比较后继字</span><br><span class="line">&#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    j=next[j]; // 模式串向右移动</span><br><span class="line">if (j&gt;T[0]) // 匹配成功</span><br><span class="line">    return i-T[0];</span><br><span class="line">else</span><br><span class="line">    return 0;</span><br><span class="line">&#125;//Index_KMP</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95%E5%8C%B9%E9%85%8D%E6%AD%A5%E9%AA%A4.PNG" alt="KMP算法匹配步骤"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//---计算next函数值---</span><br><span class="line">void get_next(SString T, int next[])</span><br><span class="line">&#123; //求模式串T的next函数值并存入数组next</span><br><span class="line">int i=1, j=0;</span><br><span class="line">next[1]=0;</span><br><span class="line">while(i&lt;T[0])</span><br><span class="line">if (j==0||T[i]==T[j])</span><br><span class="line">&#123;</span><br><span class="line">    ++i;</span><br><span class="line">    ++j;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">  j=next[j];</span><br><span class="line">&#125;//get_next</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//计算next函数的修正值</span><br><span class="line">void get_nextval(SString T,int nextval[])</span><br><span class="line">&#123;</span><br><span class="line">     i=1;nextval[1]=0;j=0;</span><br><span class="line">     while(i&lt;T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        if(j==0||T.ch[i]==T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">            if(T.ch[i]!=T.ch[j]) nextval[i]=j;</span><br><span class="line">            else nextval[i]=nextval[j];</span><br><span class="line">         &#125;</span><br><span class="line">         else j=nextval[j];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95%E6%B1%82nextval%E5%80%BC.PNG" alt="KMP求nextval值"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（3）——栈与队列</title>
      <link href="/2018/09/13/2018-09-13-data-struct-summary-3/"/>
      <url>/2018/09/13/2018-09-13-data-struct-summary-3/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="栈的表示和操作的实现"><a href="#栈的表示和操作的实现" class="headerlink" title="栈的表示和操作的实现"></a>栈的表示和操作的实现</h3><h4 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h4></li><li><strong>顺序栈的存储结构</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct     //栈的存储结构</span><br><span class="line">&#123;</span><br><span class="line">    ElemType *base;</span><br><span class="line">    ElemType *top;</span><br><span class="line">    int stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>（1） base为栈底指针，初始化完成后，栈底指针base始终指向栈底的位置，若base为NULL，则表明栈结构不存在；<br>（2） top为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1；<br>（3） 栈空时，top和base的值相等，都指向栈底；栈非空时，top始终指向栈顶元素的上一个位置；<br>（4） stacksize为栈可使用的最大容量；    </p></blockquote><ul><li><p><strong>顺序栈的初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status InitStack(SqStack &amp;S)    //栈的初始化</span><br><span class="line">&#123;</span><br><span class="line">     S.base=new ElemType[MAXSIZE];    //为顺序栈分配一个MAXSIZE的数组空间</span><br><span class="line">     if(!S.base) return ERROR;</span><br><span class="line">     S.top=S.base;</span><br><span class="line">     S.stacksize=MAXSIZE;</span><br><span class="line">     return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>压栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status Push(SqStack &amp;S,ElemType e)    //压栈</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top-S.base==S.stacksize) return ERROR;    //判断是否到达最大容量</span><br><span class="line">    *S.top=e;</span><br><span class="line">    ++S.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>出栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status Pop(SqStack &amp;S,ElemType &amp;e)    //出栈</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top==S.base) return ERROR;     //判断栈是否为空</span><br><span class="line">    e=*--S.top;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取栈顶元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status GetTop(SqStack S)    //获取栈顶元素</span><br><span class="line">&#123;</span><br><span class="line">    if(S.top!=S.base)    //判断栈是否为空</span><br><span class="line">       return *(S.top-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h4><ul><li><strong>链栈的存储结构</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct StackNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct StackNode *next;</span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>链栈的存储结构与点链表的存储结构相同，由于栈的主要操作是在栈顶插入和删除，显然以链表的头部作为栈顶是最方便的，因此链栈不需设置头结点。    </p><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status InitStack(LinkStack &amp;S)</span><br><span class="line">&#123;</span><br><span class="line">    S=NULL;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p><strong>压栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status Push(LinkStack &amp;S,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode *p;</span><br><span class="line">    InitStack(p);    //为结点开辟内存空间</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=S;</span><br><span class="line">    S=p;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>出栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status Pop(LinkStack &amp;S,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode *p;</span><br><span class="line">    e=S-&gt;data;</span><br><span class="line">    p=S;</span><br><span class="line">    S=S-&gt;next;</span><br><span class="line">    delete p;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取栈顶元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElemType GetTop(LinkStack S)</span><br><span class="line">&#123;</span><br><span class="line">    if(S!=NULL)return S-&gt;data;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h3><h4 id="循环队列—队列的顺序表示和实现"><a href="#循环队列—队列的顺序表示和实现" class="headerlink" title="循环队列—队列的顺序表示和实现"></a>循环队列—队列的顺序表示和实现</h4><ul><li><strong>队列的存储结构</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct     </span><br><span class="line">&#123;</span><br><span class="line">    ElemType *base;</span><br><span class="line">    int front; //整型变量，在此叫做头指针</span><br><span class="line">    int rear;  //整型变量，在此叫做尾指针</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>（1） 初始化创建空队列时，令<code>front=rear=0</code>；<br>（2） 每当插入新的队列尾元素时，尾指针rear增1；每当删除队列头元素时，头指针front增1；<br>（3） 在非空队列中，头指针始终指向队列头元素，尾指针始终指向队列尾元素的下一位置；<br>（4） 队空的条件：<code>Q.front=Q.rear</code><br>（5） 队满的条件：<code>(Q.rear+1)%MAXSIZE==Q.front</code>    </p><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status InitQueue(SqQueue &amp;Q)    //初始化</span><br><span class="line">&#123;</span><br><span class="line">    Q.base=new ElemType[MAXSIZE];   //Q.base指向数组空间的首地址</span><br><span class="line">    if(!Q.base) return ERROR;</span><br><span class="line">    Q.front=Q.rear=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p><strong>求队列长度</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status QueueLength(SqQueue Q)    //队列的长度</span><br><span class="line">&#123;</span><br><span class="line">    return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>入队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status EnQueue(SqQueue &amp;Q,ElemType e)    //进队列</span><br><span class="line">&#123;</span><br><span class="line">    if((Q.rear+1)%MAXSIZE==Q.front)</span><br><span class="line">        return ERROR;</span><br><span class="line">    Q.base[Q.rear]=e;</span><br><span class="line">    Q.rear=(Q.rear+1)%MAXSIZE;     //队尾指针加1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>出队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status DeQueue(SqQueue &amp;Q,ElemType &amp;e)    //出队列</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.rear==Q.front) return ERROR;</span><br><span class="line">    e=Q.base[Q.front];</span><br><span class="line">    Q.front=(Q.front+1)%MAXSIZE;    //队头指针加1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取队头元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElemType GetHead(SqQueue Q)     //获取队列头元素</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front!=Q.rear)</span><br><span class="line">        return Q.base[Q.front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="链队—队列的链式表示和实现"><a href="#链队—队列的链式表示和实现" class="headerlink" title="链队—队列的链式表示和实现"></a>链队—队列的链式表示和实现</h4><ul><li><strong>链队的初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct QNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>一个链队显然需要两个分别指向队头和队尾的指针才能确定；<br>这里为操作方便，给链队添加一个头结点，并令头指针指向头结点；    </p><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status InitQueue(LinkQueue &amp;Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front=Q.rear=new QNode;</span><br><span class="line">    Q.front-&gt;next=NULL;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p><strong>链队的入队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status EnQueue(LinkQueue &amp;Q,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    QNode *p;</span><br><span class="line">    p=new QNode;</span><br><span class="line">    p-&gt;data=e;</span><br><span class="line">    p-&gt;next=NULL;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链队的出队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status DeQueue(LinkQueue &amp;Q,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front==Q.rear) return ERROR;</span><br><span class="line">    QNode *p;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    if(Q.rear==p) Q.rear=Q.front;</span><br><span class="line">        delete p;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取队头元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ElemType GetHead(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q.front!=Q.rear)</span><br><span class="line">        return Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（2）——线性表</title>
      <link href="/2018/09/08/2018-09-08-data-struct-summary-2/"/>
      <url>/2018/09/08/2018-09-08-data-struct-summary-2/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><p><strong>线性表</strong>：由n（n≥0）个数据特性相同的元素构成的有限序列。<br>特点：<br>① 存在唯一的一个被称为“第一个”的数据元素；<br>② 存在唯一的一个被称为“最后一个”的数据元素；<br>③ 除第一个之外，结构中的每个数据元素均只有一个前驱；<br>④ 出最后一个之外，结构中的每个数据元素均只有一个后继。    </p><h3 id="线性表的类型定义"><a href="#线性表的类型定义" class="headerlink" title="线性表的类型定义"></a>线性表的类型定义</h3><p>ADT List{<br>            数据对象：D＝{ ai | ai ∈ElemSet, i=1,2,…,n,  n≥0 }<br>            数据关系：R1＝{ <ai-1 ,ai>|ai-1 ,ai∈D,  i=2,…,n } i是位序<br>            基本操作：<br>            InitList(&amp;L){构造空的线性表L}<br>            Destroy（&amp;L）{销毁}<br>            ListEmpty（L）{若L为空 返回TRUE}<br>            ListLength（L）{返回L中的元素个数，即表长}<br>            PriorElem（L,cur_e,&amp;pre_e）{cur_e为一个元素且不是第一个，则用pre_e返回它的前驱}<br>            NextElem（L,cur_e,&amp;next_e）<br>            GetElem(L,i,&amp;e){用e返回L中第i个元素的值}<br>            LocateElem（L,e,compare()）{返回L中第一个与e满足compare()的元素位序，否则返回0}<br>            ListTraverse（L,visit()）{依次对L的每个元素调用visit()函数}<br>            ClearList（&amp;L）{置空}<br>            PutElem（&amp;L，i,e）{把e覆盖第i个位置，是改变元素，不是插入}<br>            ListInsert（&amp;L,i,e）{插入的位置是i的前面}<br>            ListDelete(&amp;L,i,&amp;)<br>}ADT List     </ai-1></p><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><h4 id="线性表的顺序存储表示"><a href="#线性表的顺序存储表示" class="headerlink" title="线性表的顺序存储表示"></a>线性表的顺序存储表示</h4><p>线性表的顺序存储表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，通常也称这种存储结构额线性表为顺序表。<br>只要确定了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。    </p><blockquote><p>由于线性表的长度可变，且所需最大的存储空间随问题不同而不同，则在C语言中可用动态分配的一维数组表示线性表。    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//---顺序表的存储结构---    </span><br><span class="line">#define MAXSIZE 100    //顺序表可能达到的最大长度    </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">&amp;nbsp;&amp;nbsp;ElemType *elem;    //存储空间的基地址，ElemType可由用户自定义</span><br><span class="line">&amp;nbsp;&amp;nbsp;int length;    //当前长度</span><br><span class="line">&#125;SqList;    //顺序表的结构类型为SqList</span><br></pre></td></tr></table></figure><p>案例一：多项式的顺序存储结构类型定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 100    //顺序表可能达到的最大长度    </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">&amp;nbsp;&amp;nbsp;float coef;    //系数</span><br><span class="line">&amp;nbsp;&amp;nbsp;float expn;    //指数</span><br><span class="line">&#125;Polynomial;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">&amp;nbsp;&amp;nbsp;Polynomial *elem;    //存储空间的基地址，Polynomial由用户自定义</span><br><span class="line">&amp;nbsp;&amp;nbsp;int length;    //当前长度</span><br><span class="line">&#125;SqList;    //顺序表的结构类型为SqList</span><br></pre></td></tr></table></figure></p><p>案例二：图书数据的顺序存储结构类型定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 10000    //图书表可能达到的最大长度    </span><br><span class="line">typedef struct    //图书信息定义</span><br><span class="line">&#123;</span><br><span class="line">  char no[20];    //图书ISBN</span><br><span class="line">  char name[50];  //图书名字</span><br><span class="line">&#125;Book;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Book *elem;    //存储空间的基地址，Book由用户自定义</span><br><span class="line">  int length;    //当前长度</span><br><span class="line">&#125;SqList;    //顺序表的结构类型为SqList</span><br></pre></td></tr></table></figure></p><p>在上述定以后，可通过变量定义语句<code>SqList L;</code>将L定义成SqList类型的变量；<br>使用<code>L.elem[i-1]</code>访问序号为i的图书记录。    </p><h4 id="顺序表中基本操作的实现"><a href="#顺序表中基本操作的实现" class="headerlink" title="顺序表中基本操作的实现"></a>顺序表中基本操作的实现</h4><ul><li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList *L)&#123;    //构造一个空的顺序表L</span><br><span class="line">    L-&gt; elem=new ElemType[MAXSIZE];   //为顺序表分配空间</span><br><span class="line">    if(! L-&gt; elem) exit(OVERFLOW);       //存储分配失败</span><br><span class="line">    L-&gt; length=0;              //空表长度为0</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_Sq(SqList *L)&#123;    //构造一个空的顺序表L</span><br><span class="line">    L.elem=new ElemType[MAXSIZE];   //为顺序表分配空间</span><br><span class="line">    if(! L.elem) exit(OVERFLOW);       //存储分配失败</span><br><span class="line">    L.length=0;              //空表长度为0</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><strong>销毁</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DestroyList(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">  if (L.elem) delete[]L.elem;    //释放存储空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>清空</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void ClearList(SqList &amp;L) </span><br><span class="line">&#123;</span><br><span class="line">   L.length=0;                //将线性表的长度置为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线性表长度</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int GetLength(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">   return (L.length);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断线性表是否为空</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int IsEmpty(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">  if (L.length==0) return 1;      </span><br><span class="line">   else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>取值</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//根据指定位置，获取相应位置数据元素的内容</span><br><span class="line">int GetElem(SqList L,int i,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">  if (i&lt;1||i&gt;L.length) return ERROR;   </span><br><span class="line">   //判断i值是否合理，若不合理，返回ERROR</span><br><span class="line">  e=L.elem[i-1];   //第i-1的单元存储着第i个数据</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>查找</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int LocateELem(SqList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">  for (i=0;i&lt; L.length;i++)</span><br><span class="line">      if (L.elem[i]==e) return i+1;                </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_Sq(SqList &amp;L,int i ,ElemType e)&#123;</span><br><span class="line">   if(i&lt;1 || i&gt;L.length+1) return ERROR;         //i值不合法</span><br><span class="line">   if(L.length==MAXSIZE) return ERROR;    //当前存储空间已满     </span><br><span class="line">   for(j=L.length-1;j&gt;=i-1;j--) </span><br><span class="line">       L.elem[j+1]=L.elem[j];    //插入位置及之后的元素后移</span><br><span class="line">    L.elem[i-1]=e;                     //将新元素e放入第i个位置</span><br><span class="line">  ++L.length;     //表长增1</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">   if((i&lt;1)||(i&gt;L.length)) return ERROR; //i值不合法</span><br><span class="line">   e=L.elem[i-1];                              //将欲删除的元素保留在e中</span><br><span class="line">  for (j=i;j&lt;=L.length-1;j++)                   </span><br><span class="line">　  　L.elem[j-1]=L.elem[j];       //被删除元素之后的元素前移  </span><br><span class="line">   --L.length;                     //表长减1</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><h4 id="单链表的定义和表示"><a href="#单链表的定义和表示" class="headerlink" title="单链表的定义和表示"></a>单链表的定义和表示</h4><ul><li><strong>结点</strong>：存储本身的信息以及存储指示其后继信息的存储映像；</li><li><strong>数据域</strong>：存储数据元素信息的域称为数据域；</li><li><strong>指针域</strong>：存储直接后继存储位置的域；</li><li>n个结点链接成一个链表，又由于此链表的每个结点只包含一个指针域，故又称<strong>线性链表</strong>或<strong>单链表</strong>；</li><li>链表分为：单链表、循环链表、双向链表、二叉链表、十字链表、邻接表、邻接多重表；</li><li>其中单链表、循环链表和双向链表用于实现线性表的链式存储，其他形式多用于实现树和图等非线性结构；</li><li>单链表时非随机存取的存储结构，取第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存取结构。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//---单链表的存储结构---</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">     ElemType   data;       //数据域</span><br><span class="line">     struct LNode  *next;   //指针域</span><br><span class="line">&#125;LNode,*LinkList;   // *LinkList为Lnode类型的指针</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>LinkList与LNode<em>本质上是等价的。通常使用LinkList定义单链表，强调定义的是某个单链表的头指针；<br>用LNode</em>定义指向单链表中任一结点的指针变量。<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%B4%E6%8C%87%E9%92%88%E5%A4%B4%E7%BB%93%E7%82%B9%E9%A6%96%E5%85%83%E7%BB%93%E7%82%B9.png" alt="头指针头节点首元结点">    </p></blockquote><p>链表增加头结点的作用：<br>（1）便于首元结点的处理：首元结点地址保存在头结点的指针域中，使其和其他数据元素操作一样；<br>（2）便于空表和非空表的统一处理：当不设头结点时，假设L为单链表的头指针，则当单链表的长度n为0的空表时，L指针为空（L==NULL）；当增加头结点后，无论链表是否为空，头指针都是指向头结点的非空结点，即若为空表，头结点的指针域为空（L-&gt;next==NULL)；    </p><h4 id="单链表基本操作的实现"><a href="#单链表基本操作的实现" class="headerlink" title="单链表基本操作的实现"></a>单链表基本操作的实现</h4><ul><li><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status InitList_L(LinkList &amp;L)&#123; </span><br><span class="line">   L=new LNode;                    </span><br><span class="line">   L-&gt;next=NULL;　　　　　</span><br><span class="line">   return OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status DestroyList_L(LinkList &amp;L)&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">       while(L)</span><br><span class="line">        &#123;</span><br><span class="line">            p=L;  </span><br><span class="line">            L=L-&gt;next;</span><br><span class="line">            delete p;  </span><br><span class="line">        &#125;</span><br><span class="line">     return OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>清空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ClearList(LinkList &amp; L)&#123;</span><br><span class="line">  // 将L重置为空表 </span><br><span class="line">   LinkList p,q;</span><br><span class="line">   p=L-&gt;next;   //p指向第一个结点</span><br><span class="line">   while(p)       //没到表尾 </span><br><span class="line">      &#123;  q=p-&gt;next; delete p; p=q;   &#125;</span><br><span class="line">   L-&gt;next=NULL;   //头结点指针域为空 </span><br><span class="line">   return OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>求表长</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int  ListLength_L(LinkList L)&#123;</span><br><span class="line">//返回L中数据元素个数</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L-&gt;next;         //p指向第一个结点</span><br><span class="line">     i=0;             </span><br><span class="line">     while(p)&#123;           //遍历单链表,统计结点数</span><br><span class="line">           i++;</span><br><span class="line">           p=p-&gt;next;    &#125; </span><br><span class="line">    return i;                             </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>判断是否为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ListEmpty(LinkList L)&#123; </span><br><span class="line">//若L为空表，则返回1，否则返回0 </span><br><span class="line">   if(L-&gt;next)   //非空 </span><br><span class="line">     return 0;</span><br><span class="line">   else</span><br><span class="line">     return 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status GetElem_L(LinkList L,int i,ElemType &amp;e)&#123; </span><br><span class="line">    p=L-&gt;next;j=1; //初始化</span><br><span class="line">     while(p&amp;&amp;j&lt;i)&#123;//向后扫描，直到p指向第i个元素或p为空 </span><br><span class="line">       p=p-&gt;next; ++j; </span><br><span class="line">     &#125; </span><br><span class="line">     if(!p || j&gt;i)return ERROR; //第i个元素不存在 </span><br><span class="line">     e=p-&gt;data; //取第i个元素 </span><br><span class="line">     return OK; </span><br><span class="line">&#125;//GetElem_L</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LNode *LocateELem_L (LinkList L，Elemtype e) &#123; </span><br><span class="line">  p=L-&gt;next; </span><br><span class="line">  while(p &amp;&amp;p-&gt;data!=e)  </span><br><span class="line">        p=p-&gt;next;                </span><br><span class="line">  return p; //返回L中值为e的数据元素的位置，查找失败返回NULL </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_L(LinkList &amp;L,int i,ElemType e)&#123; </span><br><span class="line">     p=L;j=0; </span><br><span class="line">      while(p&amp;&amp;j&lt;i−1)&#123;p=p-&gt;next;++j;&#125;//寻找第i−1个结点 </span><br><span class="line">      if(!p||j&gt;i−1)return ERROR;//i大于表长 + 1或者小于1  </span><br><span class="line">      s=new LNode;//生成新结点s </span><br><span class="line">      s-&gt;data=e;                 //将结点s的数据域置为e </span><br><span class="line">      s-&gt;next=p-&gt;next;             //将结点s插入L中 </span><br><span class="line">      p-&gt;next=s; </span><br><span class="line">      return OK; </span><br><span class="line">&#125;//ListInsert_L</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">    p=L;j=0; </span><br><span class="line">    while(p-&gt;next &amp;&amp;j&lt;i-1)&#123;//寻找第i个结点，并令p指向其前驱 </span><br><span class="line">        p=p-&gt;next; ++j; </span><br><span class="line">    &#125; </span><br><span class="line">    if(!(p-&gt;next)||j&gt;i-1) return ERROR; //删除位置不合理 </span><br><span class="line">    q=p-&gt;next; //临时保存被删结点的地址以备释放 </span><br><span class="line">    p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域 </span><br><span class="line">    e=q-&gt;data; //保存删除结点的数据域 </span><br><span class="line">    delete q; //释放删除结点的空间 </span><br><span class="line"> return OK; </span><br><span class="line">&#125;//ListDelete_L</span><br></pre></td></tr></table></figure></li><li><p>创建单链表（前插法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_F(LinkList &amp;L,int n)&#123; </span><br><span class="line">     L=new LNode; </span><br><span class="line">      L-&gt;next=NULL; //先建立一个带头结点的单链表 </span><br><span class="line">      for(i=n;i&gt;0;--i)&#123; </span><br><span class="line">        p=new LNode; //生成新结点 </span><br><span class="line">        cin&gt;&gt;p-&gt;data; //输入元素值 </span><br><span class="line">        p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头 </span><br><span class="line">     &#125; </span><br><span class="line">&#125;//CreateList_F</span><br></pre></td></tr></table></figure></li><li><p>创建单链表（后插法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void CreateList_L(LinkList &amp;L,int n)&#123; </span><br><span class="line">      //正位序输入n个元素的值，建立带表头结点的单链表L </span><br><span class="line">      L=new LNode; </span><br><span class="line">      L-&gt;next=NULL; </span><br><span class="line">      r=L; //尾指针r指向头结点 </span><br><span class="line">      for(i=0;i&lt;n;++i)&#123; </span><br><span class="line">        p=new LNode;　//生成新结点 </span><br><span class="line">        cin&gt;&gt;p-&gt;data;   //输入元素值 </span><br><span class="line">        p-&gt;next=NULL; r-&gt;next=p;     //插入到表尾 </span><br><span class="line">        r=p; //r指向新的尾结点 </span><br><span class="line">      &#125; </span><br><span class="line">&#125;//CreateList_L</span><br></pre></td></tr></table></figure></li></ul><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表：最后一个结点的指针域指向头结点，形成一个环，因此从表中任一结点出发均可找到表中其他结点。<br>循环单链表的操作和单链表基本一致，差别在于：当链表遍历时，判别当前指针p是否指向表尾的终止条件不同。在单链表中，判断条件为<code>p!=NULL或p-&gt;next!=NULL</code>再循环单链表中判断条件为<code>p!=L或p-&gt;next!=L</code><br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6.PNG" alt="循环链表的合并"></p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//---双向链表的存储结构---</span><br><span class="line">typedef struct DuLNode&#123;</span><br><span class="line">    ElemType   data;              </span><br><span class="line">    struct DuLNode  *prior;  </span><br><span class="line">    struct DuLNode  *next;  </span><br><span class="line">&#125;DuLNode, *DuLinkList</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.PNG" alt="双向循环链表"></p><ul><li><p>双向链表的插入<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.PNG" alt="双向链表的插入"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e)&#123;</span><br><span class="line">   if(!(p=GetElemP_DuL(L,i))) return ERROR;</span><br><span class="line">    s=new DuLNode; </span><br><span class="line">   s-&gt;data=e;</span><br><span class="line">   s-&gt;prior=p-&gt;prior;  ①</span><br><span class="line">   p-&gt;prior-&gt;next=s;   ②</span><br><span class="line">   s-&gt;next=p;          ③</span><br><span class="line">   p-&gt;prior=s;         ④</span><br><span class="line">   return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双向链表的删除<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4.PNG" alt="双向链表的删除"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete_DuL(DuLinkList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">   if(!(p=GetElemP_DuL(L,i)))     return ERROR;</span><br><span class="line">   e=p-&gt;data;</span><br><span class="line">   p-&gt;prior-&gt;next=p-&gt;next;     ①</span><br><span class="line">   p-&gt;next-&gt;prior=p-&gt;prior;    ②</span><br><span class="line">   delete p; </span><br><span class="line">   return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单算法实现</title>
      <link href="/2018/09/08/2018-09-08-Algorithm-demo/"/>
      <url>/2018/09/08/2018-09-08-Algorithm-demo/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="复数抽象数据类型的定义及操作"><a href="#复数抽象数据类型的定义及操作" class="headerlink" title="复数抽象数据类型的定义及操作"></a>复数抽象数据类型的定义及操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ERROR 0 </span><br><span class="line">typedef float status;</span><br><span class="line"></span><br><span class="line">typedef struct    //抽象数据类型的存储结构</span><br><span class="line">&#123;</span><br><span class="line">    float Realpart;</span><br><span class="line">    float Imagepart;</span><br><span class="line">&#125;Complex;</span><br><span class="line"></span><br><span class="line">void Create(Complex &amp;C,float x,float y)   //构建复数</span><br><span class="line">&#123;</span><br><span class="line">    C.Realpart=x;</span><br><span class="line">    C.Imagepart=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status GetReal(Complex C)    //取实部</span><br><span class="line">&#123;</span><br><span class="line">    return C.Realpart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status GetImag(Complex C)    //取虚部</span><br><span class="line">&#123;</span><br><span class="line">    return C.Imagepart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Add(Complex C1,Complex C2)    //复数相加</span><br><span class="line">&#123;</span><br><span class="line">    Complex sum;</span><br><span class="line">    sum.Realpart=C1.Realpart+C2.Realpart;</span><br><span class="line">    sum.Imagepart=C1.Imagepart+C2.Imagepart;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex Sub(Complex C1,Complex C2)    //复数相减</span><br><span class="line">&#123;</span><br><span class="line">    Complex dif;</span><br><span class="line">    dif.Realpart=C1.Realpart-C2.Realpart;</span><br><span class="line">    dif.Imagepart=C1.Imagepart-C2.Imagepart;</span><br><span class="line">    return dif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    Complex C1,C2,C3,C4;</span><br><span class="line">    cout&lt;&lt;&quot;请输入第一个复数！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    cin&gt;&gt;C1.Realpart;</span><br><span class="line">    cin&gt;&gt;C1.Imagepart;</span><br><span class="line">    cout&lt;&lt;&quot;请输入第二个复数！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    cin&gt;&gt;C2.Realpart;</span><br><span class="line">    cin&gt;&gt;C2.Imagepart;</span><br><span class="line">    cout&lt;&lt;&quot;C1实部为：&quot;&lt;&lt;GetReal(C1)&lt;&lt;&quot;C1虚部为：&quot;&lt;&lt;GetImag(C1)&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    C3=Add(C1,C2);</span><br><span class="line">    C4=Sub(C1,C2);</span><br><span class="line">    cout&lt;&lt;&quot;和为：&quot;&lt;&lt;C3.Realpart&lt;&lt;&quot;+&quot;&lt;&lt;C3.Imagepart&lt;&lt;&quot;i&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">    cout&lt;&lt;&quot;差为：&quot;&lt;&lt;C4.Realpart&lt;&lt;&quot;+&quot;&lt;&lt;C4.Imagepart&lt;&lt;&quot;i&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个有序表的合并（顺序表）"><a href="#两个有序表的合并（顺序表）" class="headerlink" title="两个有序表的合并（顺序表）"></a>两个有序表的合并（顺序表）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OK 1</span><br><span class="line">typedef int status;</span><br><span class="line">typedef int Elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct    //抽象数据类型的存储结构</span><br><span class="line">&#123;</span><br><span class="line">    Elemtype *elem;</span><br><span class="line">int length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">status initlist(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">L.elem=new Elemtype[MAXSIZE];</span><br><span class="line">if(!L.elem) return ERROR;</span><br><span class="line">L.length=0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqList createlist(int n)</span><br><span class="line">&#123;</span><br><span class="line">SqList L;</span><br><span class="line">initlist(L);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;L.elem[i];</span><br><span class="line">++L.length;</span><br><span class="line">&#125;</span><br><span class="line">return L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void merge(SqList L1,SqList L2,SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">int *p,*p1,*p2,*p1_last,*p2_last;</span><br><span class="line">initlist(L);</span><br><span class="line">L.length=L1.length+L2.length;</span><br><span class="line">p=L.elem;p1=L1.elem;p2=L2.elem;</span><br><span class="line">p1_last=L1.elem+L1.length-1;</span><br><span class="line">p2_last=L2.elem+L2.length-1;</span><br><span class="line">while((p1&lt;=p1_last)&amp;&amp;(p2&lt;=p2_last))</span><br><span class="line">&#123;</span><br><span class="line">    if(*p1&lt;=*p2) *p++=*p1++;</span><br><span class="line">else *p++=*p2++;</span><br><span class="line">&#125;</span><br><span class="line">while(p1&lt;=p1_last) *p++=*p1++;</span><br><span class="line">while(p2&lt;=p2_last) *p++=*p2++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123; </span><br><span class="line">SqList L1,L2,L;</span><br><span class="line">initlist(L1);</span><br><span class="line">initlist(L2);</span><br><span class="line">initlist(L);</span><br><span class="line">cout&lt;&lt;&quot;请输入4个数字！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">L1=createlist(4);</span><br><span class="line">cout&lt;&lt;&quot;请输入3个数字！&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">L2=createlist(3);</span><br><span class="line">merge(L1,L2,L);</span><br><span class="line">for(int j=0;j&lt;L.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;L.elem[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序表的合并（单链表）"><a href="#有序表的合并（单链表）" class="headerlink" title="有序表的合并（单链表）"></a>有序表的合并（单链表）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OK 1</span><br><span class="line">typedef int status;</span><br><span class="line">typedef int Elemtype;</span><br><span class="line"></span><br><span class="line">typedef struct LNode</span><br><span class="line">&#123;</span><br><span class="line">    Elemtype data;</span><br><span class="line">struct LNode *next;</span><br><span class="line">&#125;LNode,*Linklist;</span><br><span class="line"></span><br><span class="line">status init(Linklist &amp;L)    //链表初始化</span><br><span class="line">&#123; </span><br><span class="line">    L=new LNode;    //为链表开辟内存空间</span><br><span class="line">L-&gt;next=NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void create_L(Linklist &amp;L,int n)     //后插法</span><br><span class="line">&#123;</span><br><span class="line">LNode *p,*r;</span><br><span class="line">L=new LNode;   //开辟内存空间</span><br><span class="line">L-&gt;next=NULL;  //创建一个链表</span><br><span class="line">r=L;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    p=new LNode;    //创建结点</span><br><span class="line">cin&gt;&gt;p-&gt;data;</span><br><span class="line">p-&gt;next=NULL;</span><br><span class="line">r-&gt;next=p;</span><br><span class="line">r=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeList_L(Linklist La,Linklist Lb,Linklist &amp;Lc)&#123;     //合并有序链表</span><br><span class="line">   LNode *pa,*pb,*pc,*a;</span><br><span class="line">   init(Lc);    //******这是必须的！！！</span><br><span class="line">   pa=La-&gt;next;  pb=Lb-&gt;next; </span><br><span class="line">   pc=Lc=La;             //用La的头结点作为Lc的头结点 </span><br><span class="line">   while(pa &amp;&amp; pb)&#123;</span><br><span class="line">      if(pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;&#125;</span><br><span class="line">      else&#123;pc-&gt;next=pb; pc=pb; pb=pb-&gt;next;&#125;</span><br><span class="line">   pc-&gt;next=pa?pa:pb;    //插入剩余段  </span><br><span class="line">   //delete a;             //释放Lb的头结点  </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">LNode *p,*L1,*L2,*L,*p1,*p2;</span><br><span class="line">cout&lt;&lt;&quot;请输入3个数字&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">create_L(L1,3);</span><br><span class="line">cout&lt;&lt;&quot;创建成功！&quot;&lt;&lt;&quot;第一个序列是：&quot;;</span><br><span class="line">p1=L1-&gt;next;</span><br><span class="line">while(p1)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p1-&gt;data;</span><br><span class="line">p1=p1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;请输入4个数字&quot;&lt;&lt;&quot;\n&quot;;</span><br><span class="line">create_L(L2,4);</span><br><span class="line">cout&lt;&lt;&quot;创建成功！&quot;&lt;&lt;&quot;第二个序列是：&quot;;</span><br><span class="line">p2=L2-&gt;next;</span><br><span class="line">while(p2)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p2-&gt;data;</span><br><span class="line">p2=p2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">MergeList_L(L1,L2,L);</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">cout&lt;&lt;&quot;输出为&quot;&lt;&lt;&quot;&quot;;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p-&gt;data;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构知识点（1）——绪论</title>
      <link href="/2018/09/07/2018-09-07-data-struct-summary-1/"/>
      <url>/2018/09/07/2018-09-07-data-struct-summary-1/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="数据结构研究内容"><a href="#数据结构研究内容" class="headerlink" title="数据结构研究内容"></a>数据结构研究内容</h3><ul><li><strong>数值计算</strong><br>计算机主要用于数值计算，主要步骤包括：①从具体问题中抽象出数学模型；②设计解决此数学模型的算法；③编写程序，进行调试。<br>寻找数学模型的实质是分析问题，从中提取操作对象，并找出这些操作对象之间的关系，然后用数学语言加以描述，即建立相应的数学方程。    </li><li><strong>非数值计算</strong><br>非数值问题的数学模型不再是数学方程，而是诸如线性表、树和图的数据结构。<br><strong>数据结构是一门研究非数值（抽象数据类型）计算程序设计中的操作对象，以及这些对象之间的关系和操作的学科。</strong>       </li></ul><hr><h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><ul><li><strong>数据</strong><br>所有能输入到计算机中并被计算机程序处理的符号总称；（整数/实数/字符串/图形/声音/动画经特殊编码后的数据）    </li><li><strong>数据元素</strong><br>数据的基本单位，也称元素、记录。数据元素用于完整地描述一个操作对象，如花名单中一名学生记录、树中棋盘的一个状态、图中的一个顶点；    </li><li><strong>数据项</strong><br>组成数据元素的、有独立含义的、不可分割的最小单位。如学生基本信息表中的学号、姓名、性别都是数据项；    </li><li><strong>数据对象</strong><br>性质相同的数据元素的集合，是数据的一个子集。    </li></ul><hr><ul><li>数据结构的<strong>逻辑结构</strong><br>从逻辑上描述数据，与数据的存储无关，可以看作是从具体问题中抽象出来的数学模型。<br>逻辑结构的两个要素：一是数据元素；二是关系。<br>（1）_线性结构_：线性表、栈和队列、字符串、数组、广义表；<br>（2）_非线性结构_：树和二叉树、有向图和无向图。    </li><li>数据结构的<strong>存储结构</strong><br>数据对象在计算机中的存储表示称为数据的存储结构，也称物理结构。<br>将数据对象存储到计算机的时候通常要考虑存储数据元素的数据，又要存储数据元素之间的逻辑关系。<br>存储结构包括：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>。    </li></ul><hr><ul><li><strong>抽象数据类型</strong><br>抽象数据类型是指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。<br>具体包括三部分：数据对象、数据对象上关系的集合，以及对数据对象的基本操作的集合。<br>ADT 抽象数据类型名{<br>&nbsp;&nbsp; 数据对象：&lt;数据对象的定义&gt;<br>&nbsp;&nbsp; 数据关系：&lt;数据关系的定义&gt;<br>&nbsp;&nbsp; 基本操作：&lt;基本操作的定义&gt;<br>}ADT&nbsp; 抽象数据类型名<br>基本操作名（参数表）<br>&nbsp;&nbsp; 初始条件：&lt;初始条件描述&gt;<br>&nbsp;&nbsp; 操作结果：&lt;操作结果描述&gt;<br>基本操作有两种参数：<strong>赋值参数</strong>只为操作提供输入值；<strong>引用参数</strong>以”&amp;”打头，既可以提供输入值，还可返回操作结果。         </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用caffe训练数据集</title>
      <link href="/2018/08/24/2018-08-24-caffe-train-data/"/>
      <url>/2018/08/24/2018-08-24-caffe-train-data/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3>（1） 结合Caffe平台，进一步掌握Caffe的使用流程；<br>（2） 进一步理解Caffe卷积神经网络定义和优化思想；<br>（3） 学会使用prototxt定义卷积神经网络和优化方法；<br>（4） 能看懂卷积神经网络的关键代码；<br>（5） 能独立完成卷积神经网络和优化自定义；<br>（6） 运行自己的数据，解决自己在实践或科研过程中要解决的计算机视觉问题。</li></ul><h3 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h3><ul><li>硬件准备：GPU（若使用GPU模式），此选项可选择</li><li>软件准备：Caffe  </li><li>数据准备：自己要识别的数据集<h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3>使用Caffe自定义网络结构和优化方案，识别分类自己的数据集。<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4>在网上找大巴车、恐龙、大象、鲜花和马五个图像数据集，编号分别以3,4,5,6,7开头，每个种类100张，其中80张作为训练集，20张作为测试集。因此最终训练图片400张，测试图片100张。<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4>训练集目录：/home/joczu/caffe-master/data/re/train<br>测试集目录：/home/joczu/caffe-master/data/re/val<br>sh文件目录：/home/joczu/caffe-master/examples/myfile<h4 id="预处理（生成标签）"><a href="#预处理（生成标签）" class="headerlink" title="预处理（生成标签）"></a>预处理（生成标签）</h4>编写create_filelist.sh文件，使用<br><pre><code>find $DATA/train -name $i*.jpg | cut -d '/' -f4-5 | sed "s/$/ $i/">>$MY/train.txt</code></pre><br>把每个图片的名称和上级目录名给截取出来，并分别以开头数字3,4,5,6,7作为一个种类的标签。<br><pre><code><h1 id="usr-bin-env-sh"><a href="#usr-bin-env-sh" class="headerlink" title="/usr/bin/env sh"></a>/usr/bin/env sh</h1>DATA1=”/home/joczu/caffe-master/data/re”<br>DATA2=”/home/joczu/caffe-master/data/re/train/cat”<br>DATA3=”/home/joczu/caffe-master/data/re/train/dog”<br>DATA4=”/home/joczu/caffe-master/data/re/val”</code></pre></li></ul><p>echo “Create train.txt…”</p><p>rm -rf $DATA1/train.txt<br>rm -rf $DATA1/val.txt</p><p>find $DATA2 -name Abyssinian<em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 1/“&gt;&gt;$DATA1/train.txt<br>find $DATA3 -name american_bulldog</em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 2/“&gt;&gt;$DATA1/tmp.txt<br>find $DATA4 -name Abyssinian<em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 1/“&gt;&gt;$DATA1/val.txt<br>find $DATA4 -name american_bulldog</em>.jpg | cut -d ‘/‘ -f8-9 | sed “s/$/ 2/“&gt;&gt;$DATA1/tmp_val.txt</p><p>cat $DATA1/tmp.txt&gt;&gt;$DATA1/train.txt<br>cat $DATA1/tmp_val.txt&gt;&gt;$DATA1/val.txt<br>rm -rf $DATA1/tmp.txt<br>rm -rf $DATA1/tmp_val.txt</p><p>echo “Done..”<br>&lt;/code&gt;&lt;/pre&gt;</p><h4 id="转换lmdb数据格式"><a href="#转换lmdb数据格式" class="headerlink" title="转换lmdb数据格式"></a>转换lmdb数据格式</h4><p>编写creat_lmdb.sh文件，首先转换图片大小，像素均变化成256X256，再调用build/tools/convert_imageset转换图片的数据格式，生成img_test_lmdb和img_train_lmdb文件</p><p><pre><code></code></pre></p><h1 id="usr-bin-env-sh-1"><a href="#usr-bin-env-sh-1" class="headerlink" title="!/usr/bin/env sh"></a>!/usr/bin/env sh</h1><p>MY=examples/myfile</p><p>echo “Creating train lmdb…”<br>rm -rf $MY/img_train_lmdb<br>build/tools/convert_imageset \<br>—shuffle \<br>—resize_height=256 \<br>—resize_width=256 \</p><h1 id="data-re-train"><a href="#data-re-train" class="headerlink" title="/data/re/train \"></a>/data/re/train \</h1><p>$MY/train.txt \<br>$MY/img_train_lmdb<br>echo “Done.”</p><p>echo “Creating test lmdb..”<br>rm -rf $MY/img_test_lmdb<br>build/tools/convert_imageset \<br>—shuffle \<br>—resize_width=256 \<br>—resize_height=256 \</p><h1 id="data-re-val"><a href="#data-re-val" class="headerlink" title="/data/re/val \"></a>/data/re/val \</h1><p>$MY/val.txt \<br>$MY/img_test_lmdb<br>echo “All Done.”<br>&lt;/code&gt;&lt;/pre&gt;<br>到此数据的预处理完成。</p><h4 id="生成均值文件"><a href="#生成均值文件" class="headerlink" title="生成均值文件"></a>生成均值文件</h4><p>图片减去均值再训练，会提高训练速度和精度。因此，一般都会有这个操作。<br>caffe程序提供了一个计算均值的文件compute_image_mean.cpp，我们直接使用就可以了。<br>compute_image_mean带两个参数，第一个参数是lmdb训练数据位置，第二个参数设定均值文件的名字及保存路径。 运行成功后，会在 examples/myfile/ 下面生成一个mean.binaryproto的均值文件。</p><h4 id="创建训练模型"><a href="#创建训练模型" class="headerlink" title="创建训练模型"></a>创建训练模型</h4><p>模型就用程序自带的caffenet模型，位置在 models/bvlc_reference_caffenet/文件夹下,<br>将需要的两个配置文件，复制到myfile文件夹内，<br>修改其中的solver.prototxt</p><p><pre><code>net: "examples/myfile/train_val.prototxt"test_iter: 2test_interval: 50base_lr: 0.001lr_policy: "step"gamma: 0.1stepsize: 100display: 20max_iter: 200momentum: 0.9weight_decay: 0.005solver_mode: CPUsnapshot: 200snapshot_prefix: "examples/myfile/myfile"</code></pre><br>100个测试数据，batch_size为50，因此test_iter设置为2，就能全cover了。在训练过程中，调整学习率，逐步变小。<br>相关参数解释：<br>_net: “examples/myfile/train_val.prototxt” 网络模型的路径。注意的是：文件的路径要从caffe的根目录开始，其它的所有配置都是这样<br>test_iter: 2 这个要结合layer理解，表示两层；<br>test_interval: 50 测试间隔。也就是每训练50次，才进行一次测试<br>base_lr: 0.001 base_lr用于设置基础学习率，在迭代的过程中，可以对基础学习率进行调整。怎么样进行调整，就是调整的策略，由lr_policy来设置<br>lr_policy: “step” 如果设置为step,则还需要设置一个stepsize, 返回 base_lr * gamma ^ (floor(iter / stepsize)),其中iter表示当前的迭代次数<br>gamma: 0.1 上一次梯度更新的权重<br>stepsize: 100<br>display: 20 每训练２0次，在屏幕上显示一次。如果设置为0，则不显示<br>max_iter: 200 最大迭代次数。这个数设置太小，会导致没有收敛，精确度很低。设置太大，会导致震荡，浪费时间<br>momentum: 0.9 上一次梯度更新的权重<br>weight_decay: 0.005 权重衰减项，防止过拟合的一个参数<br>solver_mode: CPU 设置运行模式。默认为GPU,如果你没有GPU,则需要改成CPU，否则会出错<br>snapshot: 200<br>snapshot_prefix: “examples/myfile/myfile”_<br>修改train_val.protxt，只需要修改两个阶段的data层的文件目录</p><p><pre><code>name: "CaffeNet"layer {  name: "data"  type: "Data"  top: "data"  top: "label"  include {    phase: TRAIN  }  transform_param {    mirror: true    crop_size: 227    mean_file: "data/re/imagenet_mean.binaryproto"  }  data_param {    source: "examples/myfile/imagenet_train_leveldb"    batch_size: 256    backend: LMDB  }}layer {  name: "data"  type: "Data"  top: "data"  top: "label"  include {    phase: TEST  }  transform_param {    mirror: false    crop_size: 227    mean_file: "data/re/imagenet_mean.binaryproto"  }  data_param {    source: "examples/myfile/imagenet_val_leveldb"    batch_size: 20    backend: LMDB  }}</code></pre></p><h4 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h4><p>在caffe根目录下输入以下命令</p><p><pre><code>build/tools/caffe train -solver examples/myfile/solver.prototxt</code></pre><br>接下来就是等待训练完成，训练时间大约需要1.5小时<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/caffe%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C/caffe%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C.png" alt="caffe训练结果"><br>训练到此完成，从结果可以看出训练精度为92％<br><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/caffe%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C/caffe%E8%AE%AD%E7%BB%83%E7%94%9F%E6%88%90%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6.png" alt="caffe训练生成中间文件"><br>生成许多中间文件。</p><h3 id="实验问题及解决方法"><a href="#实验问题及解决方法" class="headerlink" title="实验问题及解决方法"></a>实验问题及解决方法</h3><p>（1） 本次实验很大的问题就是路径问题，有的地方在使用相对路径的时候需要在caffe-master目录下运行sh文件；<br>（2） 注意训练集、测试集、sh文件放置的相应位置，以免出现不可名状的错误；<br>（3） 注意设置solver.protptxt及train_val.prototxt文件的参数设置，需根据自己的训练集和测试集进行匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> caffe 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割——钢铁表面缺陷检测</title>
      <link href="/2018/08/24/2018-08-24-image-segmentation/"/>
      <url>/2018/08/24/2018-08-24-image-segmentation/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="实验思路"><a href="#实验思路" class="headerlink" title="实验思路"></a>实验思路</h3><p>先对原图进行几何变化（旋转）变成长方形，再对图像进行分割</p><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p><pre><code>clearclcinit=imread('C:\Users\joczu\Desktop\作业3.bmp');%图像旋转G=rgb2gray(init);E=edge(G);theta=1:180;[R,xp]=radon(E,theta);[E,J]=find(R>=max(max(R)));Q=90-J;I=imrotate(G,Q,'bilinear','crop');%图像切割s=I(:,:,1);bw=im2bw(s,graythresh(s));  %graythresh自动找比较合适的阈值se=strel('disk',1);  %创建切割形状bw2=imclose(bw,se);figure(1);imshow(bw2);perim=bwperim(bw2,8); %表示从输入图像BW1中返回只包括对象边缘坐标r=I(:,:,1);%g=I(:,:,2);%b=I(:,:,3);r(perim)=250;%g(perim)=0;%b(perim)=0;I(:,:,1)=r;%I(:,:,2)=g;%I(:,:,3)=b;figure(2);imshow(I);</code></pre></p><h3 id="实验截图"><a href="#实验截图" class="headerlink" title="实验截图"></a>实验截图</h3><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/图像分割-钢铁表面检测/图像分割-钢铁表面检测.png" alt="钢铁表面缺陷分割"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DICOM医学图像处理</title>
      <link href="/2018/08/21/2018-08-21-DICOM-process/"/>
      <url>/2018/08/21/2018-08-21-DICOM-process/</url>
      
        <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>最大灰度投影（MIP）是临床上最常见的一种血管成像方式，要求将三维数据沿z轴投影。</p><h3 id="实验提示"><a href="#实验提示" class="headerlink" title="实验提示"></a>实验提示</h3><p>将每层DICOM图像对应位置像素点依次比较取最大。</p><h3 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h3><p>MATLAB</p><h3 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h3><p><pre><code>clear allclcclose allfile_path =  'E:\data\'; % 图像文件夹路径  img_path_list = dir(strcat(file_path,'*.dcm'));%获取该文件夹中所有dcm格式的图像  img_num = length(img_path_list);%获取图像总数量  imagemax = img_path_list(1).name;% 图像名imagemax =dicomread(strcat(file_path,imagemax)); %%dcm变成灰度图for w=1:400    for u=1:400        tmp=double(imagemax(w,u));        imagemax(w,u)=uint8(255*(tmp-17)/2407);    endend%%比较        for j = 1:img_num %逐一读取图像              image_name = img_path_list(j).name;% 图像名            image =dicomread(strcat(file_path,image_name));            for c=1:400                for d=1:400                    tem=double(image(c,d));                    image(c,d)=uint8(255*(tem-17)/2407);                end            end            for m=1:400                for n=1:400                    imagemax(m,n)=max(image(m,n),imagemax(m,n));                end            end        end  imshow(imagemax,[]);</code></pre></p><h3 id="实验截图"><a href="#实验截图" class="headerlink" title="实验截图"></a>实验截图</h3><p><img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/DICOM%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/DICOM.png" alt="DICOM医学图像"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN 知识点</title>
      <link href="/2018/08/17/2018-08-17-CNN/"/>
      <url>/2018/08/17/2018-08-17-CNN/</url>
      
        <content type="html"><![CDATA[<h3 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络(CNN)"></a>卷积神经网络(CNN)</h3><p>1、    深度学习中极具代表性的网络结构之一，常用于图像处理，避免对图像复杂的特征提取，可直接输入原始图像；<br><br>2、    传统的神经网络都是采用输入层到隐藏层全连接的方式，这样导致参数量巨大；而CNN通过局部连接、权值共享方式连接来降低权值参数；<br></p><p>3、    局部连接：</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/%E5%B1%80%E9%83%A8%E8%BF%9E%E6%8E%A5.png" alt="全连接与局部连接"></p><p>4、    权值共享：</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/%E6%9D%83%E5%80%BC%E5%85%B1%E4%BA%AB.png" alt="权值共享"></p><p> 10*10个权值参数，也就是卷积核（也称滤波器）的大小。一个卷积核只能提取图像的一种特征，使用不同大小的卷积核可以得到图像的不同映射下的特征，称之为Feature Map。另外偏置参数也是共享的，同一种滤波器共享一个；<br><br>5、    卷积神经网络的核心思想是：局部感受野（local field），权值共享以及时间或者空间亚采样相结合，获取某种程度的位移、尺度、形变不变性；<br><br>6、    经典的CNN结构——LeNet-5网络</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%E7%BD%91%E7%BB%9C.png" alt="LeNet-5网络"></p><p>CNN主要由两种类型的网络层，分别是卷积层和池化/采样层（pooling）。卷积层的作用是提取图像的各种特征；池化层是对原始特征信号进行抽象，从而大幅度减少训练参数，另外还可以减轻模型过拟合的程度。<br><br>卷积层：</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/%E5%8D%B7%E7%A7%AF.png" alt="卷积"></p><p>池化/采样层：<br>通过不变性（平移、旋转、尺度）保留feature maps主要特征，同时减少特征。<br>通常有两种方式包括Max-Pooling（选择Pooling窗口中的最大值作为采样值）和Mean-Pooling（将Pooling窗口中的所有值相加取平均，以平均值作为采样值）</p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20C1%E5%8D%B7%E7%A7%AF%E5%B1%82.png" alt="C1"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20S2%E4%B8%8B%E9%87%87%E6%A0%B7%E5%B1%82.png" alt="S2"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20C3%E5%8D%B7%E7%A7%AF%E5%B1%82.png" alt="C3"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20S4%E4%B8%8B%E9%87%87%E6%A0%B7%E5%B1%82.png" alt="S4"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20C5%E5%8D%B7%E7%A7%AF%E5%B1%82.png" alt="C5"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20F6.png" alt="F6"></p><p> <img src="https://raw.githubusercontent.com/joczu/Picture-Set/master/CNN/LeNet-5%20%E8%BE%93%E5%87%BA%E5%B1%82.png" alt="输出层"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
